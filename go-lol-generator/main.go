package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"strings"
	"unicode"

	"github.com/kdy1997/go-lol/go-lol-generator/loldoc"
	"github.com/luci/luci-go/common/logging"
	"github.com/luci/luci-go/common/logging/gologger"
	"golang.org/x/net/context"
)

func formatFile(filename string, src []byte) ([]byte, error) {
	data, err := format.Source(src)
	if err != nil {
		return nil, err
	}

	return data, nil
}

const targetFile = "lol.generated.go"

func main() {
	c := context.Background()
	c = gologger.StdConfig.Use(c)

	gqDoc, err := loldoc.NewGoQueryDoc()
	if err != nil {
		logging.Errorf(c, "failed to create goquery document: %+v", err)
		return
	}

	doc, err := loldoc.Parse(c, gqDoc)
	if err != nil {
		logging.Errorf(c, "failed to parse lol api doc: %+v", err)
		return
	}

	generated := New(doc).Generate()
	src, err := formatFile(targetFile, generated)
	if err != nil {
		os.Stderr.Write(generated)
		logging.Errorf(c, "failed to format generated go file: %+v", err)
		return
	}

	if err := ioutil.WriteFile(targetFile, src, 0644); err != nil {
		logging.Errorf(c, "failed to write %q\nError: %+v", targetFile, err)
		return
	}
}

const pkgPath = "github.com/kdy1997/go-lol"
const uriTemplatesPkg = pkgPath + "/internal/uritemplates"
const pkgName = "lol"

type Generator struct {
	bytes.Buffer

	doc *loldoc.Doc
}

func New(doc *loldoc.Doc) *Generator {
	return &Generator{
		doc: doc,
	}
}

func (g *Generator) Generate() []byte {
	g.generateHeader()

	for _, res := range g.doc.Resources {
		g.generateResource(res)
		for _, s := range res.Definitions {
			g.generateResponseClass(s)
		}
	}

	src := g.Bytes()
	return src
}

func (g *Generator) generateHeader() {
	g.P(`// Generated by go-lol-generator. DO NOT EDIT.`)
	g.P()
	g.P(`package `, pkgName)

	g.P(`import "encoding/json"`)
	g.P(`import "io"`)
	g.P(`import "strconv"`)
	g.P(`import "net/http"`)
	g.P(`import "net/url"`)
	g.P()

	g.P(`import "golang.org/x/net/context"`)
	g.P(`import `, strconv.Quote(uriTemplatesPkg))
	g.P()

	g.P(`var _ = json.Marshal`)
	g.P(`var _ = io.EOF`)
}

func (g *Generator) generateResource(res loldoc.Resource) {
	for _, op := range res.Operations {
		g.generateOperation(res, op)
	}
}

func (g *Generator) generateOperation(res loldoc.Resource, op *loldoc.Operation) {
	overridedMapKey := op.OverridedMapKey
	hasOverride := overridedMapKey != types.Invalid

	ret := op.OrigReturnType

	if hasOverride {
		if m, ok := ret.(*types.Map); ok {
			ret = types.NewMap(types.Typ[overridedMapKey], m.Elem())
		} else {
			panic("invalid override")
		}
	}

	g.generateOpType(op)
	g.generateOpCreatorFunc(res, op)
	g.generateOpDoRequestFunc(op)

	g.P(`func (c *`, callStructOf(op), `) Do() (`, ret, `, error) {
	res, err := c.doRequest()
	if res != nil && res.Body != nil {
		defer closeBody(res)
	}
	if err != nil { return `, ZeroOf(ret), `, err }

	if err := verifyResponse(res); err != nil {
		return `, ZeroOf(ret), `, err
	}
`)

	g.DeclareVar(`ret`, op.OrigReturnType)
	g.P(`if err := json.NewDecoder(res.Body).Decode(&ret); err != nil { return `, ZeroOf(ret), `, err }`)
	if overridedMapKey != 0 {
		g.DeclareVar(`data`, ret)
		g.P(`for k, v := range ret {`)
		g.P(`i, err := strconv.ParseInt(k, 10, 64)`)
		g.P(`if err != nil { return nil, err }`)
		g.P(`data[i] = v`)
		g.P(`}`)

		g.P(`return data, nil`)
	} else {
		g.P(`return ret, nil`)
	}
	g.P(`}`)
	g.P()
}

// prints operation initialization function.
func (g *Generator) generateOpCreatorFunc(res loldoc.Resource, op *loldoc.Operation) {
	g.P()
	g.P(`// `, op.Description)
	g.P(`//`)
	if op.ImplNotes != "" {
		g.P(`//`)
		g.P(`// Implementation notes: `, op.ImplNotes)
	}
	if op.RateLimitNotes != "" {
		g.P(`//`)
		g.P(`// Rate limit notes: `, op.RateLimitNotes)
	}
	g.P(`//`)
	g.P(`//    `, op.HTTPMethod, `: `, res.APIBase(), op.RequestPath)

	// required arguments
	var args string
	if op.IsRegional() {
		args += `, region Region`
	}
	for _, p := range op.PathParams {
		if loldoc.IsRegion(p) {
			continue
		}

		args += `,  ` + p.Name + ` ` + p.Type.String()
	}

	g.P(`func (c `, clientType(op), `) `, op.MethodName, `(ctx context.Context`, args, `) *`, callStructOf(op), ` {`)
	g.P(`path := make(map[string]string)`)

	for _, p := range op.PathParams {
		if loldoc.IsRegion(p) {
			continue
		}

		if p.Required {
			g.P(`path[`, strconv.Quote(p.Name), `] = convertToString(`, p.Name, `)`)
		}
	}

	fields := `ctx: ctx, client: c, query: make(url.Values), pathParams: path, `
	if op.IsRegional() {
		fields += `region: region,`
	}

	g.P(`return &`, callStructOf(op), `{`, fields, `}`)
	g.P(`}`)
	g.P()

	for _, q := range op.QueryParams {
		g.P(`// `, q.Name, ` configures query parameter `, q.Name, `.`)
		g.P(`func (c *`, callStructOf(op), `) `, funcName(q.Name, true), `(v `, q.Type, `) (*`, callStructOf(op), `) {`)
		g.P(`c.query.Set(`, strconv.Quote(q.Name), `, convertToString(v))`)
		g.P(`return c`)
		g.P(`}`)
	}
}

func (g *Generator) generateOpType(op *loldoc.Operation) {
	g.P()
	g.P(`// `, callStructOf(op), ` is a builder for `, clientType(op), ".", op.MethodName)
	g.P(`type `, callStructOf(op), ` struct {
		ctx context.Context
		client `, clientType(op), `
		query url.Values
		pathParams map[string]string`)
	if op.IsRegional() {
		g.P(`	region Region`)
	}
	g.P(`}`)
	g.P()
}

func (g *Generator) generateOpDoRequestFunc(op *loldoc.Operation) {
	g.P()
	g.P(`func (c *`, callStructOf(op), `) doRequest() (*http.Response, error) {`)
	g.P(`var body io.Reader`)

	// Parameter validation
	if op.IsRegional() {
		g.P(`switch c.region {`)
		g.P(`case `, strings.Join(op.SupportedRegions(), ","), `:`)
		g.P(`default:
			return nil, ErrNotSupportedRegion
		}`)
	}

	if op.NeedAPIKey() {
		g.P(`c.query.Set("api_key", c.client.apiKey)`)
	}
	if op.PathParams.Has("region") {
		g.P(`c.pathParams["region"] = c.region.Name()`)
	}
	if op.PathParams.Has("platformId") {
		g.P(`c.pathParams["platformId"] = c.region.PlatformID()`)
	}
	g.P()

	var urlsTpl string

	if op.APIBase() == "" {
		urlsTpl = `c.region.baseURL()`
	} else {
		urlsTpl = strconv.Quote(op.APIBase())
	}
	g.P(`path, err := uritemplates.Expand(`, strconv.Quote(op.RequestPath), `, c.pathParams)`)
	g.P(`if err != nil { return nil, err }`)

	g.P(`urls := `, urlsTpl, ` + path + "?" + c.query.Encode()`)
	g.P()

	g.P(`return c.client.doRequest(c.ctx, `, strconv.Quote(op.HTTPMethod), `, urls, body)`)
	g.P(`}`)
	g.P()
}

func (g *Generator) generateResponseClass(s loldoc.Schema) {
	g.P()
	if s.Description != "" {
		g.P(`// `, s.Description)
		g.P(`//`)
	}
	g.P(`// resource: "`, s.ResID(), `", original name: "`, s.OrigName, `"`)
	g.P(`type `, s.StructName, ` struct {`)
	for _, f := range s.Fields {
		g.PrintComments(f.Description)
		tag := "`" + `json:"` + f.OrigName() + `"` + "`"
		g.P(f.GoName(), ` `, f.Type, tag)
	}
	g.P(`}`)
	g.P()
}

func (g *Generator) P(args ...interface{}) {
	g.WriteRune('\t')
	for _, v := range args {
		switch s := v.(type) {
		case string:
			g.WriteString(s)
		case types.Type:
			types.WriteType(&g.Buffer, s, func(pkg *types.Package) string {
				if pkg.Path() == pkgPath {
					return ""
				}

				return pkg.Name()
			})
		case ast.Expr:
			types.WriteExpr(&g.Buffer, s)
		case fmt.Stringer:
			g.WriteString(s.String())
		case bool:
			fmt.Fprintf(&g.Buffer, "%t", s)
		case *bool:
			fmt.Fprintf(&g.Buffer, "%t", *s)
		case int:
			fmt.Fprintf(&g.Buffer, "%d", s)
		case int32:
			fmt.Fprintf(&g.Buffer, "%d", s)
		case *int32:
			fmt.Fprintf(&g.Buffer, "%d", *s)
		case *int64:
			fmt.Fprintf(&g.Buffer, "%d", *s)
		case float64:
			fmt.Fprintf(&g.Buffer, "%g", s)
		case *float64:
			fmt.Fprintf(&g.Buffer, "%g", *s)
		default:
			panic(fmt.Errorf("unknown type in printer: %T", v))
		}
	}
	g.WriteByte('\n')
}

// ----- Printer utilities.

func (g *Generator) DeclareVar(name string, typ types.Type) {
	switch t := typ.(type) {
	case *types.Pointer:
		g.P(name, ` := `, `&`, t.Elem().String(), `{}`)
	case *types.Map:
		g.P(name, ` := `, `make(`, t.String(), `)`)
	case *types.Slice:
		g.P(name, ` := `, `make(`, t.String(), `, 0)`)
	case *types.Basic:
		g.P(`var `, name, ` `, t.String())
	default:
		log.Panicf("failed to decalre varaible %s with type %v", name, typ)
	}
}

func ZeroOf(typ types.Type) string {
	switch t := typ.(type) {
	case *types.Pointer, *types.Slice, *types.Map, *types.Interface:
		return "nil"
	case *types.Basic:
		switch t.Kind() {
		case types.Bool:
			return "false"
		case types.Int, types.Int8, types.Int16, types.Int32, types.Int64:
			return "0"
		}

	}
	panic(fmt.Sprintf("zeroof: unknown type %v", typ))
}

func (g *Generator) PrintComments(cmt string) {
	if cmt == "" {
		return
	}

	for _, line := range strings.Split(cmt, "\n") {
		g.P(`// `, line)
	}
}

func funcName(name string, exported bool) string {
	if len(name) == 0 {
		panic(`funcName: len == 0, ` + name)
	}
	first := []rune(name)[0]
	if exported {
		first = unicode.ToUpper(first)
	} else {
		first = unicode.ToLower(first)
	}
	return string(first) + name[1:]
}

func typeName(name string, exported bool) string {
	if len(name) == 0 {
		panic(`typeName: len == 0, ` + name)
	}
	first := []rune(name)[0]
	if exported {
		first = unicode.ToUpper(first)
	} else {
		first = unicode.ToLower(first)
	}
	return string(first) + name[1:]
}

func clientType(op *loldoc.Operation) string {
	if op.NeedAPIKey() {
		return "Client"
	}
	return "StaticClient"
}

func callStructOf(op *loldoc.Operation) string {
	return op.MethodName + "Call"
}
