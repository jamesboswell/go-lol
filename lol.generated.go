// Generated by go-lol-generator. DO NOT EDIT.

package lol

import "encoding/json"
import "io"
import "strconv"
import "net/http"
import "net/url"

import "golang.org/x/net/context"
import "github.com/kdy1997/go-lol/internal/uritemplates"

var _ = json.Marshal
var _ = io.EOF

// ChampionStatusesCall is a builder for Client.ChampionStatuses
type ChampionStatusesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve all champions. (REST)
//
//
//    GET: /api/lol/{region}/v1.2/champion
func (c Client) ChampionStatuses(ctx context.Context, region Region) *ChampionStatusesCall {
	path := make(map[string]string)
	return &ChampionStatusesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// freeToPlay configures query parameter freeToPlay.
func (c *ChampionStatusesCall) FreeToPlay(v bool) *ChampionStatusesCall {
	c.query.Set("freeToPlay", convertToString(v))
	return c
}

func (c *ChampionStatusesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.2/champion", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionStatusesCall) Do() (*ChampionStatuses, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &ChampionStatuses{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ChampionStatusCall is a builder for Client.ChampionStatus
type ChampionStatusCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve champion by ID. (REST)
//
//
//    GET: /api/lol/{region}/v1.2/champion/{id}
func (c Client) ChampionStatus(ctx context.Context, region Region, id int32) *ChampionStatusCall {
	path := make(map[string]string)
	path["id"] = convertToString(id)
	return &ChampionStatusCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *ChampionStatusCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.2/champion/{id}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionStatusCall) Do() (*ChampionStatus, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &ChampionStatus{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains champion information.
//
// resource: "champion", original name: "ChampionDto"
type ChampionStatus struct {
	// Indicates if the champion is active.
	Active bool `json:"active"`
	// Bot enabled flag (for custom games).
	BotEnabled bool `json:"botEnabled"`
	// Bot Match Made enabled flag (for Co-op vs. AI games).
	BotMmEnabled bool `json:"botMmEnabled"`
	// Indicates if the champion is free to play. Free to play champions are rotated periodically.
	FreeToPlay bool `json:"freeToPlay"`
	// Champion ID. For static information correlating to champion IDs, please refer to the LoL Static Data API.
	ID int64 `json:"id"`
	// Ranked play enabled flag.
	RankedPlayEnabled bool `json:"rankedPlayEnabled"`
}

//  - This object contains a collection of champion information.
//
// resource: "champion", original name: "ChampionListDto"
type ChampionStatuses struct {
	// The collection of champion information.
	Champions []*ChampionStatus `json:"champions"`
}

// ChampionMasteryCall is a builder for Client.ChampionMastery
type ChampionMasteryCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get a champion mastery by player id and champion id. Response code 204 means there were no masteries found for given player id or player id and champion id combination. (RPC)
//
//
//    GET: /championmastery/location/{platformId}/player/{playerId}/champion/{championId}
func (c Client) ChampionMastery(ctx context.Context, region Region, playerId int64, championId int64) *ChampionMasteryCall {
	path := make(map[string]string)
	path["playerId"] = convertToString(playerId)
	path["championId"] = convertToString(championId)
	return &ChampionMasteryCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *ChampionMasteryCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["platformId"] = c.region.PlatformID()

	path, err := uritemplates.Expand("/championmastery/location/{platformId}/player/{playerId}/champion/{championId}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionMasteryCall) Do() (*ChampionMastery, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &ChampionMastery{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ChampionMasteriesCall is a builder for Client.ChampionMasteries
type ChampionMasteriesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get all champion mastery entries sorted by number of champion points descending (RPC)
//
//
//    GET: /championmastery/location/{platformId}/player/{playerId}/champions
func (c Client) ChampionMasteries(ctx context.Context, region Region, playerId int64) *ChampionMasteriesCall {
	path := make(map[string]string)
	path["playerId"] = convertToString(playerId)
	return &ChampionMasteriesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *ChampionMasteriesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["platformId"] = c.region.PlatformID()

	path, err := uritemplates.Expand("/championmastery/location/{platformId}/player/{playerId}/champions", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionMasteriesCall) Do() ([]*ChampionMastery, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make([]*ChampionMastery, 0)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ChampionMasteryScoreCall is a builder for Client.ChampionMasteryScore
type ChampionMasteryScoreCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get a player's total champion mastery score, which is sum of individual champion mastery levels (RPC)
//
//
//    GET: /championmastery/location/{platformId}/player/{playerId}/score
func (c Client) ChampionMasteryScore(ctx context.Context, region Region, playerId int64) *ChampionMasteryScoreCall {
	path := make(map[string]string)
	path["playerId"] = convertToString(playerId)
	return &ChampionMasteryScoreCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *ChampionMasteryScoreCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["platformId"] = c.region.PlatformID()

	path, err := uritemplates.Expand("/championmastery/location/{platformId}/player/{playerId}/score", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionMasteryScoreCall) Do() (int32, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return 0, err
	}

	if err := verifyResponse(res); err != nil {
		return 0, err
	}

	var ret int32
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return 0, err
	}
	return ret, nil
}

// TopChampionsCall is a builder for Client.TopChampions
type TopChampionsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get specified number of top champion mastery entries sorted by number of champion points descending (RPC)
//
//
//    GET: /championmastery/location/{platformId}/player/{playerId}/topchampions
func (c Client) TopChampions(ctx context.Context, region Region, playerId int64) *TopChampionsCall {
	path := make(map[string]string)
	path["playerId"] = convertToString(playerId)
	return &TopChampionsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *TopChampionsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["platformId"] = c.region.PlatformID()

	path, err := uritemplates.Expand("/championmastery/location/{platformId}/player/{playerId}/topchampions", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *TopChampionsCall) Do() ([]*ChampionMastery, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make([]*ChampionMastery, 0)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains single Champion Mastery information for player and champion combination.
//
// resource: "championmastery", original name: "ChampionMasteryDTO"
type ChampionMastery struct {
	// Champion ID for this entry.
	ChampionID int64 `json:"championId"`
	// Champion level for specified player and champion combination.
	ChampionLevel int32 `json:"championLevel"`
	// Total number of champion points for this player and champion combination - they are used to determine championLevel.
	ChampionPoints int32 `json:"championPoints"`
	// Number of points earned since current level has been achieved. Zero if player reached maximum champion level for this champion.
	ChampionPointsSinceLastLevel int64 `json:"championPointsSinceLastLevel"`
	// Number of points needed to achieve next level. Zero if player reached maximum champion level for this champion.
	ChampionPointsUntilNextLevel int64 `json:"championPointsUntilNextLevel"`
	// Is chest granted for this champion or not in current season.
	ChestGranted bool `json:"chestGranted"`
	// Last time this champion was played by this player - in Unix milliseconds time format.
	LastPlayTime int64 `json:"lastPlayTime"`
	// Player ID for this entry.
	PlayerID int64 `json:"playerId"`
}

// SpectatorGameInfoCall is a builder for Client.SpectatorGameInfo
type SpectatorGameInfoCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get current game information for the given summoner ID. (REST)
//
//
//    GET: /observer-mode/rest/consumer/getSpectatorGameInfo/{platformId}/{summonerId}
func (c Client) SpectatorGameInfo(ctx context.Context, region Region, summonerId int64) *SpectatorGameInfoCall {
	path := make(map[string]string)
	path["summonerId"] = convertToString(summonerId)
	return &SpectatorGameInfoCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *SpectatorGameInfoCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["platformId"] = c.region.PlatformID()

	path, err := uritemplates.Expand("/observer-mode/rest/consumer/getSpectatorGameInfo/{platformId}/{summonerId}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *SpectatorGameInfoCall) Do() (*CurrentGameInfo, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &CurrentGameInfo{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// resource: "current-game", original name: "Rune"
type CurrentGameRune struct {
	// The count of this rune used by the participant
	Count int32 `json:"count"`
	// The ID of the rune
	RuneID int64 `json:"runeId"`
}

// resource: "current-game", original name: "Mastery"
type CurrentGameMastery struct {
	// The ID of the mastery
	MasteryID int64 `json:"masteryId"`
	// The number of points put into this mastery by the user
	Rank int32 `json:"rank"`
}

// resource: "current-game", original name: "Observer"
type CurrentGameObserver struct {
	// Key used to decrypt the spectator grid game data for playback
	EncryptionKey string `json:"encryptionKey"`
}

// resource: "current-game", original name: "CurrentGameParticipant"
type CurrentGameParticipant struct {
	// Flag indicating whether or not this participant is a bot
	Bot bool `json:"bot"`
	// The ID of the champion played by this participant
	ChampionID int64 `json:"championId"`
	// The masteries used by this participant
	Masteries []*CurrentGameMastery `json:"masteries"`
	// The ID of the profile icon used by this participant
	ProfileIconID int64 `json:"profileIconId"`
	// The runes used by this participant
	Runes []*CurrentGameRune `json:"runes"`
	// The ID of the first summoner spell used by this participant
	Spell1Id int64 `json:"spell1Id"`
	// The ID of the second summoner spell used by this participant
	Spell2Id int64 `json:"spell2Id"`
	// The summoner ID of this participant
	SummonerID int64 `json:"summonerId"`
	// The summoner name of this participant
	SummonerName string `json:"summonerName"`
	// The team ID of this participant, indicating the participant's team
	TeamID int64 `json:"teamId"`
}

// resource: "current-game", original name: "BannedChampion"
type CurrentGameBannedChampion struct {
	// The ID of the banned champion
	ChampionID int64 `json:"championId"`
	// The turn during which the champion was banned
	PickTurn int32 `json:"pickTurn"`
	// The ID of the team that banned the champion
	TeamID int64 `json:"teamId"`
}

// resource: "current-game", original name: "CurrentGameInfo"
type CurrentGameInfo struct {
	// Banned champion information
	BannedChampions []*CurrentGameBannedChampion `json:"bannedChampions"`
	// The ID of the game
	GameID int64 `json:"gameId"`
	// The amount of time in seconds that has passed since the game started
	GameLength int64 `json:"gameLength"`
	// The game mode (Legal values: CLASSIC, ODIN, ARAM, TUTORIAL, ONEFORALL, ASCENSION, FIRSTBLOOD, KINGPORO)
	GameMode string `json:"gameMode"`
	// The queue type (queue types are documented on the Game Constants page)
	GameQueueConfigID int64 `json:"gameQueueConfigId"`
	// The game start time represented in epoch milliseconds
	GameStartTime int64 `json:"gameStartTime"`
	// The game type (Legal values: CUSTOM_GAME, MATCHED_GAME, TUTORIAL_GAME)
	GameType string `json:"gameType"`
	// The ID of the map
	MapID int64 `json:"mapId"`
	// The observer information
	Observers *CurrentGameObserver `json:"observers"`
	// The participant information
	Participants []*CurrentGameParticipant `json:"participants"`
	// The ID of the platform on which the game is being played
	PlatformID string `json:"platformId"`
}

// FeaturedGamesCall is a builder for Client.FeaturedGames
type FeaturedGamesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get list of featured games. (REST)
//
//
//    GET: /observer-mode/rest/featured
func (c Client) FeaturedGames(ctx context.Context, region Region) *FeaturedGamesCall {
	path := make(map[string]string)
	return &FeaturedGamesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *FeaturedGamesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)

	path, err := uritemplates.Expand("/observer-mode/rest/featured", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *FeaturedGamesCall) Do() (*FeaturedGames, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &FeaturedGames{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// resource: "featured-games", original name: "FeaturedGames"
type FeaturedGames struct {
	// The suggested interval to wait before requesting FeaturedGames again
	ClientRefreshInterval int64 `json:"clientRefreshInterval"`
	// The list of featured games
	GameList []*FeaturedGameInfo `json:"gameList"`
}

// resource: "featured-games", original name: "Participant"
type FeaturedGameParticipant struct {
	// Flag indicating whether or not this participant is a bot
	Bot bool `json:"bot"`
	// The ID of the champion played by this participant
	ChampionID int64 `json:"championId"`
	// The ID of the profile icon used by this participant
	ProfileIconID int64 `json:"profileIconId"`
	// The ID of the first summoner spell used by this participant
	Spell1Id int64 `json:"spell1Id"`
	// The ID of the second summoner spell used by this participant
	Spell2Id int64 `json:"spell2Id"`
	// The summoner name of this participant
	SummonerName string `json:"summonerName"`
	// The team ID of this participant, indicating the participant's team
	TeamID int64 `json:"teamId"`
}

// resource: "featured-games", original name: "Observer"
type FeaturedGameObserver struct {
	// Key used to decrypt the spectator grid game data for playback
	EncryptionKey string `json:"encryptionKey"`
}

// resource: "featured-games", original name: "BannedChampion"
type FeaturedGameBannedChampion struct {
	// The ID of the banned champion
	ChampionID int64 `json:"championId"`
	// The turn during which the champion was banned
	PickTurn int32 `json:"pickTurn"`
	// The ID of the team that banned the champion
	TeamID int64 `json:"teamId"`
}

// resource: "featured-games", original name: "FeaturedGameInfo"
type FeaturedGameInfo struct {
	// Banned champion information
	BannedChampions []*FeaturedGameBannedChampion `json:"bannedChampions"`
	// The ID of the game
	GameID int64 `json:"gameId"`
	// The amount of time in seconds that has passed since the game started
	GameLength int64 `json:"gameLength"`
	// The game mode (Legal values: CLASSIC, ODIN, ARAM, TUTORIAL, ONEFORALL, ASCENSION, FIRSTBLOOD, KINGPORO)
	GameMode string `json:"gameMode"`
	// The queue type (queue types are documented on the Game Constants page)
	GameQueueConfigID int64 `json:"gameQueueConfigId"`
	// The game start time represented in epoch milliseconds
	GameStartTime int64 `json:"gameStartTime"`
	// The game type (Legal values: CUSTOM_GAME, MATCHED_GAME, TUTORIAL_GAME)
	GameType string `json:"gameType"`
	// The ID of the map
	MapID int64 `json:"mapId"`
	// The observer information
	Observers *FeaturedGameObserver `json:"observers"`
	// The participant information
	Participants []*FeaturedGameParticipant `json:"participants"`
	// The ID of the platform on which the game is being played
	PlatformID string `json:"platformId"`
}

// RecentGamesCall is a builder for Client.RecentGames
type RecentGamesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get recent games by summoner ID. (REST)
//
//
//    GET: /api/lol/{region}/v1.3/game/by-summoner/{summonerId}/recent
func (c Client) RecentGames(ctx context.Context, region Region, summonerId int64) *RecentGamesCall {
	path := make(map[string]string)
	path["summonerId"] = convertToString(summonerId)
	return &RecentGamesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *RecentGamesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.3/game/by-summoner/{summonerId}/recent", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *RecentGamesCall) Do() (*RecentGames, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &RecentGames{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains raw stat information.
//
// resource: "game", original name: "RawStatsDto"
type GamePlayerRawStats struct {
	Assists int32 `json:"assists"`
	// Number of enemy inhibitors killed.
	BarracksKilled        int32 `json:"barracksKilled"`
	BountyLevel           int32 `json:"bountyLevel"`
	ChampionsKilled       int32 `json:"championsKilled"`
	CombatPlayerScore     int32 `json:"combatPlayerScore"`
	ConsumablesPurchased  int32 `json:"consumablesPurchased"`
	DamageDealtPlayer     int32 `json:"damageDealtPlayer"`
	DoubleKills           int32 `json:"doubleKills"`
	FirstBlood            int32 `json:"firstBlood"`
	Gold                  int32 `json:"gold"`
	GoldEarned            int32 `json:"goldEarned"`
	GoldSpent             int32 `json:"goldSpent"`
	Item0                 int32 `json:"item0"`
	Item1                 int32 `json:"item1"`
	Item2                 int32 `json:"item2"`
	Item3                 int32 `json:"item3"`
	Item4                 int32 `json:"item4"`
	Item5                 int32 `json:"item5"`
	Item6                 int32 `json:"item6"`
	ItemsPurchased        int32 `json:"itemsPurchased"`
	KillingSprees         int32 `json:"killingSprees"`
	LargestCriticalStrike int32 `json:"largestCriticalStrike"`
	LargestKillingSpree   int32 `json:"largestKillingSpree"`
	LargestMultiKill      int32 `json:"largestMultiKill"`
	// Number of tier 3 items built.
	LegendaryItemsCreated           int32 `json:"legendaryItemsCreated"`
	Level                           int32 `json:"level"`
	MagicDamageDealtPlayer          int32 `json:"magicDamageDealtPlayer"`
	MagicDamageDealtToChampions     int32 `json:"magicDamageDealtToChampions"`
	MagicDamageTaken                int32 `json:"magicDamageTaken"`
	MinionsDenied                   int32 `json:"minionsDenied"`
	MinionsKilled                   int32 `json:"minionsKilled"`
	NeutralMinionsKilled            int32 `json:"neutralMinionsKilled"`
	NeutralMinionsKilledEnemyJungle int32 `json:"neutralMinionsKilledEnemyJungle"`
	NeutralMinionsKilledYourJungle  int32 `json:"neutralMinionsKilledYourJungle"`
	// Flag specifying if the summoner got the killing blow on the nexus.
	NexusKilled                    bool  `json:"nexusKilled"`
	NodeCapture                    int32 `json:"nodeCapture"`
	NodeCaptureAssist              int32 `json:"nodeCaptureAssist"`
	NodeNeutralize                 int32 `json:"nodeNeutralize"`
	NodeNeutralizeAssist           int32 `json:"nodeNeutralizeAssist"`
	NumDeaths                      int32 `json:"numDeaths"`
	NumItemsBought                 int32 `json:"numItemsBought"`
	ObjectivePlayerScore           int32 `json:"objectivePlayerScore"`
	PentaKills                     int32 `json:"pentaKills"`
	PhysicalDamageDealtPlayer      int32 `json:"physicalDamageDealtPlayer"`
	PhysicalDamageDealtToChampions int32 `json:"physicalDamageDealtToChampions"`
	PhysicalDamageTaken            int32 `json:"physicalDamageTaken"`
	// Player position (Legal values: TOP(1), MIDDLE(2), JUNGLE(3), BOT(4))
	PlayerPosition int32 `json:"playerPosition"`
	// Player role (Legal values: DUO(1), SUPPORT(2), CARRY(3), SOLO(4))
	PlayerRole       int32 `json:"playerRole"`
	PlayerScore0     int32 `json:"playerScore0"`
	PlayerScore1     int32 `json:"playerScore1"`
	PlayerScore2     int32 `json:"playerScore2"`
	PlayerScore3     int32 `json:"playerScore3"`
	PlayerScore4     int32 `json:"playerScore4"`
	PlayerScore5     int32 `json:"playerScore5"`
	PlayerScore6     int32 `json:"playerScore6"`
	PlayerScore7     int32 `json:"playerScore7"`
	PlayerScore8     int32 `json:"playerScore8"`
	PlayerScore9     int32 `json:"playerScore9"`
	QuadraKills      int32 `json:"quadraKills"`
	SightWardsBought int32 `json:"sightWardsBought"`
	// Number of times first champion spell was cast.
	Spell1Cast int32 `json:"spell1Cast"`
	// Number of times second champion spell was cast.
	Spell2Cast int32 `json:"spell2Cast"`
	// Number of times third champion spell was cast.
	Spell3Cast int32 `json:"spell3Cast"`
	// Number of times fourth champion spell was cast.
	Spell4Cast                  int32 `json:"spell4Cast"`
	SummonSpell1Cast            int32 `json:"summonSpell1Cast"`
	SummonSpell2Cast            int32 `json:"summonSpell2Cast"`
	SuperMonsterKilled          int32 `json:"superMonsterKilled"`
	Team                        int32 `json:"team"`
	TeamObjective               int32 `json:"teamObjective"`
	TimePlayed                  int32 `json:"timePlayed"`
	TotalDamageDealt            int32 `json:"totalDamageDealt"`
	TotalDamageDealtToChampions int32 `json:"totalDamageDealtToChampions"`
	TotalDamageTaken            int32 `json:"totalDamageTaken"`
	TotalHeal                   int32 `json:"totalHeal"`
	TotalPlayerScore            int32 `json:"totalPlayerScore"`
	TotalScoreRank              int32 `json:"totalScoreRank"`
	TotalTimeCrowdControlDealt  int32 `json:"totalTimeCrowdControlDealt"`
	TotalUnitsHealed            int32 `json:"totalUnitsHealed"`
	TripleKills                 int32 `json:"tripleKills"`
	TrueDamageDealtPlayer       int32 `json:"trueDamageDealtPlayer"`
	TrueDamageDealtToChampions  int32 `json:"trueDamageDealtToChampions"`
	TrueDamageTaken             int32 `json:"trueDamageTaken"`
	TurretsKilled               int32 `json:"turretsKilled"`
	UnrealKills                 int32 `json:"unrealKills"`
	VictoryPointTotal           int32 `json:"victoryPointTotal"`
	VisionWardsBought           int32 `json:"visionWardsBought"`
	WardKilled                  int32 `json:"wardKilled"`
	WardPlaced                  int32 `json:"wardPlaced"`
	// Flag specifying whether or not this game was won.
	Win bool `json:"win"`
}

//  - This object contains player information.
//
// resource: "game", original name: "PlayerDto"
type GamePlayer struct {
	// Champion id associated with player.
	ChampionID int32 `json:"championId"`
	// Summoner id associated with player.
	SummonerID int64 `json:"summonerId"`
	// Team id associated with player.
	TeamID int32 `json:"teamId"`
}

//  - This object contains game information.
//
// resource: "game", original name: "GameDto"
type Game struct {
	// Champion ID associated with game.
	ChampionID int32 `json:"championId"`
	// Date that end game data was recorded, specified as epoch milliseconds.
	CreateDate int64 `json:"createDate"`
	// Other players associated with the game.
	FellowPlayers []*GamePlayer `json:"fellowPlayers"`
	// Game ID.
	GameID int64 `json:"gameId"`
	// Game mode. (Legal values: CLASSIC, ODIN, ARAM, TUTORIAL, ONEFORALL, ASCENSION, FIRSTBLOOD, KINGPORO)
	GameMode string `json:"gameMode"`
	// Game type. (Legal values: CUSTOM_GAME, MATCHED_GAME, TUTORIAL_GAME)
	GameType string `json:"gameType"`
	// Invalid flag.
	Invalid bool `json:"invalid"`
	// IP Earned.
	IPEarned int32 `json:"ipEarned"`
	// Level.
	Level int32 `json:"level"`
	// Map ID.
	MapID int32 `json:"mapId"`
	// ID of first summoner spell.
	Spell1 int32 `json:"spell1"`
	// ID of second summoner spell.
	Spell2 int32 `json:"spell2"`
	// Statistics associated with the game for this summoner.
	Stats *GamePlayerRawStats `json:"stats"`
	// Game sub-type. (Legal values: NONE, NORMAL, BOT, RANKED_SOLO_5x5, RANKED_PREMADE_3x3, RANKED_PREMADE_5x5, ODIN_UNRANKED, RANKED_TEAM_3x3, RANKED_TEAM_5x5, NORMAL_3x3, BOT_3x3, CAP_5x5, ARAM_UNRANKED_5x5, ONEFORALL_5x5, FIRSTBLOOD_1x1, FIRSTBLOOD_2x2, SR_6x6, URF, URF_BOT, NIGHTMARE_BOT, ASCENSION, HEXAKILL, KING_PORO, COUNTER_PICK, BILGEWATER)
	SubType string `json:"subType"`
	// Team ID associated with game. Team ID 100 is blue team. Team ID 200 is purple team.
	TeamID int32 `json:"teamId"`
}

//  - This object contains recent games information.
//
// resource: "game", original name: "RecentGamesDto"
type RecentGames struct {
	// Collection of recent games played (max 10).
	Games []*Game `json:"games"`
	// Summoner ID.
	SummonerID int64 `json:"summonerId"`
}

// LeaguesBySummonerIDCall is a builder for Client.LeaguesBySummonerID
type LeaguesBySummonerIDCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get leagues mapped by summoner ID for a given list of summoner IDs. (REST)
//
//
// Implementation notes: Returns all leagues for specified summoners and summoners' teams. Entries for each requested participant (i.e., each summoner and related teams) will be included in the returned leagues data, whether or not the participant is inactive. However, no entries for other inactive summoners or teams in the leagues will be included.
//
//    GET: /api/lol/{region}/v2.5/league/by-summoner/{summonerIds}
func (c Client) LeaguesBySummonerID(ctx context.Context, region Region, summonerIds []int64) *LeaguesBySummonerIDCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &LeaguesBySummonerIDCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *LeaguesBySummonerIDCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.5/league/by-summoner/{summonerIds}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *LeaguesBySummonerIDCall) Do() (map[string][]*League, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string][]*League)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// LeagueEntriesBySummonerIDCall is a builder for Client.LeagueEntriesBySummonerID
type LeagueEntriesBySummonerIDCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get league entries mapped by summoner ID for a given list of summoner IDs. (REST)
//
//
// Implementation notes: Returns all league entries for specified summoners and summoners' teams.
//
//    GET: /api/lol/{region}/v2.5/league/by-summoner/{summonerIds}/entry
func (c Client) LeagueEntriesBySummonerID(ctx context.Context, region Region, summonerIds []int64) *LeagueEntriesBySummonerIDCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &LeagueEntriesBySummonerIDCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *LeagueEntriesBySummonerIDCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.5/league/by-summoner/{summonerIds}/entry", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *LeagueEntriesBySummonerIDCall) Do() (map[string][]*League, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string][]*League)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// LeaguesByTeamIDCall is a builder for Client.LeaguesByTeamID
type LeaguesByTeamIDCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get leagues mapped by team ID for a given list of team IDs. (REST)
//
//
// Implementation notes: Returns all leagues for specified teams. Entries for each requested team will be included in the returned leagues data, whether or not the team is inactive. However, no entries for other inactive teams in the leagues will be included.
//
//    GET: /api/lol/{region}/v2.5/league/by-team/{teamIds}
func (c Client) LeaguesByTeamID(ctx context.Context, region Region, teamIds string) *LeaguesByTeamIDCall {
	path := make(map[string]string)
	path["teamIds"] = convertToString(teamIds)
	return &LeaguesByTeamIDCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *LeaguesByTeamIDCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.5/league/by-team/{teamIds}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *LeaguesByTeamIDCall) Do() (map[string][]*League, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string][]*League)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// LeagueEntriesByTeamIDCall is a builder for Client.LeagueEntriesByTeamID
type LeagueEntriesByTeamIDCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get league entries mapped by team ID for a given list of team IDs. (REST)
//
//
// Implementation notes: Returns all league entries for specified teams.
//
//    GET: /api/lol/{region}/v2.5/league/by-team/{teamIds}/entry
func (c Client) LeagueEntriesByTeamID(ctx context.Context, region Region, teamIds string) *LeagueEntriesByTeamIDCall {
	path := make(map[string]string)
	path["teamIds"] = convertToString(teamIds)
	return &LeagueEntriesByTeamIDCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *LeagueEntriesByTeamIDCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.5/league/by-team/{teamIds}/entry", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *LeagueEntriesByTeamIDCall) Do() (map[string][]*League, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string][]*League)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ChallengerCall is a builder for Client.Challenger
type ChallengerCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get challenger tier leagues. (REST)
//
//
//    GET: /api/lol/{region}/v2.5/league/challenger
func (c Client) Challenger(ctx context.Context, region Region) *ChallengerCall {
	path := make(map[string]string)
	return &ChallengerCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// type configures query parameter type.
func (c *ChallengerCall) Type(v string) *ChallengerCall {
	c.query.Set("type", convertToString(v))
	return c
}

func (c *ChallengerCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.5/league/challenger", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChallengerCall) Do() (*League, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &League{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// MasterCall is a builder for Client.Master
type MasterCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get master tier leagues. (REST)
//
//
//    GET: /api/lol/{region}/v2.5/league/master
func (c Client) Master(ctx context.Context, region Region) *MasterCall {
	path := make(map[string]string)
	return &MasterCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// type configures query parameter type.
func (c *MasterCall) Type(v string) *MasterCall {
	c.query.Set("type", convertToString(v))
	return c
}

func (c *MasterCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.5/league/master", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MasterCall) Do() (*League, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &League{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains league participant information representing a summoner or team.
//
// resource: "league", original name: "LeagueEntryDto"
type LeagueEntry struct {
	// The league division of the participant.
	Division string `json:"division"`
	// Specifies if the participant is fresh blood.
	IsFreshBlood bool `json:"isFreshBlood"`
	// Specifies if the participant is on a hot streak.
	IsHotStreak bool `json:"isHotStreak"`
	// Specifies if the participant is inactive.
	IsInactive bool `json:"isInactive"`
	// Specifies if the participant is a veteran.
	IsVeteran bool `json:"isVeteran"`
	// The league points of the participant.
	LeaguePoints int32 `json:"leaguePoints"`
	// The number of losses for the participant.
	Losses int32 `json:"losses"`
	// Mini series data for the participant. Only present if the participant is currently in a mini series.
	MiniSeries *MiniSeries `json:"miniSeries"`
	// The ID of the participant (i.e., summoner or team) represented by this entry.
	PlayerOrTeamID string `json:"playerOrTeamId"`
	// The name of the the participant (i.e., summoner or team) represented by this entry.
	PlayerOrTeamName string `json:"playerOrTeamName"`
	// The playstyle of the participant. (Legal values: NONE, SOLO, SQUAD, TEAM)
	Playstyle string `json:"playstyle"`
	// The number of wins for the participant.
	Wins int32 `json:"wins"`
}

//  - This object contains league information.
//
// resource: "league", original name: "LeagueDto"
type League struct {
	// The requested league entries.
	Entries []*LeagueEntry `json:"entries"`
	// This name is an internal place-holder name only. Display and localization of names in the game client are handled client-side.
	Name string `json:"name"`
	// Specifies the relevant participant that is a member of this league (i.e., a requested summoner ID, a requested team ID, or the ID of a team to which one of the requested summoners belongs). Only present when full league is requested so that participant's entry can be identified. Not present when individual entry is requested.
	ParticipantID string `json:"participantId"`
	// The league's queue type. (Legal values: RANKED_SOLO_5x5, RANKED_TEAM_3x3, RANKED_TEAM_5x5)
	Queue string `json:"queue"`
	// The league's tier. (Legal values: CHALLENGER, MASTER, DIAMOND, PLATINUM, GOLD, SILVER, BRONZE)
	Tier string `json:"tier"`
}

//  - This object contains mini series information.
//
// resource: "league", original name: "MiniSeriesDto"
type MiniSeries struct {
	// Number of current losses in the mini series.
	Losses int32 `json:"losses"`
	// String showing the current, sequential mini series progress where 'W' represents a win, 'L' represents a loss, and 'N' represents a game that hasn't been played yet.
	Progress string `json:"progress"`
	// Number of wins required for promotion.
	Target int32 `json:"target"`
	// Number of current wins in the mini series.
	Wins int32 `json:"wins"`
}

// ChampionsCall is a builder for Client.Champions
type ChampionsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves champion list. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the champData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/champion
func (c Client) Champions(ctx context.Context, region Region) *ChampionsCall {
	path := make(map[string]string)
	return &ChampionsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *ChampionsCall) Locale(v string) *ChampionsCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *ChampionsCall) Version(v string) *ChampionsCall {
	c.query.Set("version", convertToString(v))
	return c
}

// dataById configures query parameter dataById.
func (c *ChampionsCall) DataById(v bool) *ChampionsCall {
	c.query.Set("dataById", convertToString(v))
	return c
}

// champData configures query parameter champData.
func (c *ChampionsCall) ChampData(v string) *ChampionsCall {
	c.query.Set("champData", convertToString(v))
	return c
}

func (c *ChampionsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/champion", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionsCall) Do() (*Champions, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Champions{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ChampionCall is a builder for Client.Champion
type ChampionCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves a champion by its id. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the champData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/champion/{id}
func (c Client) Champion(ctx context.Context, region Region, id int32) *ChampionCall {
	path := make(map[string]string)
	path["id"] = convertToString(id)
	return &ChampionCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *ChampionCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/champion/{id}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ChampionCall) Do() (*Champion, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Champion{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ItemsCall is a builder for Client.Items
type ItemsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves item list. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the itemListData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/item
func (c Client) Items(ctx context.Context, region Region) *ItemsCall {
	path := make(map[string]string)
	return &ItemsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *ItemsCall) Locale(v string) *ItemsCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *ItemsCall) Version(v string) *ItemsCall {
	c.query.Set("version", convertToString(v))
	return c
}

// itemListData configures query parameter itemListData.
func (c *ItemsCall) ItemListData(v string) *ItemsCall {
	c.query.Set("itemListData", convertToString(v))
	return c
}

func (c *ItemsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/item", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ItemsCall) Do() (*Items, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Items{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ItemCall is a builder for Client.Item
type ItemCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves item by its unique id. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the itemData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/item/{id}
func (c Client) Item(ctx context.Context, region Region, id int32) *ItemCall {
	path := make(map[string]string)
	path["id"] = convertToString(id)
	return &ItemCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *ItemCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/item/{id}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ItemCall) Do() (*Item, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Item{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// LanguageStringsCall is a builder for Client.LanguageStrings
type LanguageStringsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve language strings data. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/language-strings
func (c Client) LanguageStrings(ctx context.Context, region Region) *LanguageStringsCall {
	path := make(map[string]string)
	return &LanguageStringsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *LanguageStringsCall) Locale(v string) *LanguageStringsCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *LanguageStringsCall) Version(v string) *LanguageStringsCall {
	c.query.Set("version", convertToString(v))
	return c
}

func (c *LanguageStringsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/language-strings", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *LanguageStringsCall) Do() (*LanguageStrings, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &LanguageStrings{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// LanguagesCall is a builder for Client.Languages
type LanguagesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve supported languages data. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/languages
func (c Client) Languages(ctx context.Context, region Region) *LanguagesCall {
	path := make(map[string]string)
	return &LanguagesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *LanguagesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/languages", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *LanguagesCall) Do() ([]string, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make([]string, 0)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// MapsCall is a builder for Client.Maps
type MapsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve map data. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/map
func (c Client) Maps(ctx context.Context, region Region) *MapsCall {
	path := make(map[string]string)
	return &MapsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *MapsCall) Locale(v string) *MapsCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *MapsCall) Version(v string) *MapsCall {
	c.query.Set("version", convertToString(v))
	return c
}

func (c *MapsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/map", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MapsCall) Do() (*Maps, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Maps{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// MasteriesCall is a builder for Client.Masteries
type MasteriesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves mastery list. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the masteryListData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/mastery
func (c Client) Masteries(ctx context.Context, region Region) *MasteriesCall {
	path := make(map[string]string)
	return &MasteriesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *MasteriesCall) Locale(v string) *MasteriesCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *MasteriesCall) Version(v string) *MasteriesCall {
	c.query.Set("version", convertToString(v))
	return c
}

// masteryListData configures query parameter masteryListData.
func (c *MasteriesCall) MasteryListData(v string) *MasteriesCall {
	c.query.Set("masteryListData", convertToString(v))
	return c
}

func (c *MasteriesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/mastery", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MasteriesCall) Do() (*Masteries, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Masteries{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// MasteryCall is a builder for Client.Mastery
type MasteryCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves mastery item by its unique id. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the masteryData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/mastery/{id}
func (c Client) Mastery(ctx context.Context, region Region, id int32) *MasteryCall {
	path := make(map[string]string)
	path["id"] = convertToString(id)
	return &MasteryCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *MasteryCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/mastery/{id}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MasteryCall) Do() (*Mastery, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Mastery{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// RealmCall is a builder for Client.Realm
type RealmCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve realm data. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/realm
func (c Client) Realm(ctx context.Context, region Region) *RealmCall {
	path := make(map[string]string)
	return &RealmCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *RealmCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/realm", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *RealmCall) Do() (*Realm, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Realm{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// RunesCall is a builder for Client.Runes
type RunesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves rune list. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the runeListData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/rune
func (c Client) Runes(ctx context.Context, region Region) *RunesCall {
	path := make(map[string]string)
	return &RunesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *RunesCall) Locale(v string) *RunesCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *RunesCall) Version(v string) *RunesCall {
	c.query.Set("version", convertToString(v))
	return c
}

// runeListData configures query parameter runeListData.
func (c *RunesCall) RuneListData(v string) *RunesCall {
	c.query.Set("runeListData", convertToString(v))
	return c
}

func (c *RunesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/rune", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *RunesCall) Do() (*Runes, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Runes{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// RuneCall is a builder for Client.Rune
type RuneCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves rune by its unique id. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the runeData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/rune/{id}
func (c Client) Rune(ctx context.Context, region Region, id int32) *RuneCall {
	path := make(map[string]string)
	path["id"] = convertToString(id)
	return &RuneCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *RuneCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/rune/{id}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *RuneCall) Do() (*Rune, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Rune{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// SummonerSpellsCall is a builder for Client.SummonerSpells
type SummonerSpellsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves summoner spell list. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the spellData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/summoner-spell
func (c Client) SummonerSpells(ctx context.Context, region Region) *SummonerSpellsCall {
	path := make(map[string]string)
	return &SummonerSpellsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

// locale configures query parameter locale.
func (c *SummonerSpellsCall) Locale(v string) *SummonerSpellsCall {
	c.query.Set("locale", convertToString(v))
	return c
}

// version configures query parameter version.
func (c *SummonerSpellsCall) Version(v string) *SummonerSpellsCall {
	c.query.Set("version", convertToString(v))
	return c
}

// dataById configures query parameter dataById.
func (c *SummonerSpellsCall) DataById(v bool) *SummonerSpellsCall {
	c.query.Set("dataById", convertToString(v))
	return c
}

// spellData configures query parameter spellData.
func (c *SummonerSpellsCall) SpellData(v string) *SummonerSpellsCall {
	c.query.Set("spellData", convertToString(v))
	return c
}

func (c *SummonerSpellsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/summoner-spell", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *SummonerSpellsCall) Do() (*SummonerSpells, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &SummonerSpells{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// SummonerSpellCall is a builder for Client.SummonerSpell
type SummonerSpellCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieves summoner spell by its unique id. (REST)
//
//
// Implementation notes: Not all data specified below is returned by default. See the spellData parameter for more information.
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/summoner-spell/{id}
func (c Client) SummonerSpell(ctx context.Context, region Region, id int32) *SummonerSpellCall {
	path := make(map[string]string)
	path["id"] = convertToString(id)
	return &SummonerSpellCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *SummonerSpellCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/summoner-spell/{id}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *SummonerSpellCall) Do() (*SummonerSpell, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &SummonerSpell{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// VersionsCall is a builder for Client.Versions
type VersionsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve version data. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://global.api.pvp.net/api/lol/static-data/{region}/v1.2/versions
func (c Client) Versions(ctx context.Context, region Region) *VersionsCall {
	path := make(map[string]string)
	return &VersionsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *VersionsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, PBE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/static-data/{region}/v1.2/versions", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://global.api.pvp.net" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *VersionsCall) Do() ([]string, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make([]string, 0)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains champion level tip data.
//
// resource: "lol-static-data", original name: "LevelTipDto"
type LevelTip struct {
	Effect []string `json:"effect"`
	Label  []string `json:"label"`
}

//  - This object contains item list data.
//
// resource: "lol-static-data", original name: "ItemListDto"
type Items struct {
	Basic   *BasicData       `json:"basic"`
	Data    map[string]*Item `json:"data"`
	Groups  []*ItemGroup     `json:"groups"`
	Tree    []*ItemTree      `json:"tree"`
	Type    string           `json:"type"`
	Version string           `json:"version"`
}

//  - This object contains rune data.
//
// resource: "lol-static-data", original name: "RuneDto"
type Rune struct {
	Colloq               string          `json:"colloq"`
	ConsumeOnFull        bool            `json:"consumeOnFull"`
	Consumed             bool            `json:"consumed"`
	Depth                int32           `json:"depth"`
	Description          string          `json:"description"`
	From                 []string        `json:"from"`
	Group                string          `json:"group"`
	HideFromAll          bool            `json:"hideFromAll"`
	ID                   int32           `json:"id"`
	Image                *Image          `json:"image"`
	InStore              bool            `json:"inStore"`
	Into                 []string        `json:"into"`
	Maps                 map[string]bool `json:"maps"`
	Name                 string          `json:"name"`
	Plaintext            string          `json:"plaintext"`
	RequiredChampion     string          `json:"requiredChampion"`
	Rune                 *RuneMetadata   `json:"rune"`
	SanitizedDescription string          `json:"sanitizedDescription"`
	SpecialRecipe        int32           `json:"specialRecipe"`
	Stacks               int32           `json:"stacks"`
	Stats                *BasicStats     `json:"stats"`
	Tags                 []string        `json:"tags"`
}

//  - This object contains champion recommended block item data.
//
// resource: "lol-static-data", original name: "BlockItemDto"
type RecommendedItems struct {
	Count int32 `json:"count"`
	ID    int32 `json:"id"`
}

//  - This object contains champion recommended data.
//
// resource: "lol-static-data", original name: "RecommendedDto"
type Recommended struct {
	Blocks   []*RecommendedBlock `json:"blocks"`
	Champion string              `json:"champion"`
	Map      string              `json:"map"`
	Mode     string              `json:"mode"`
	Priority bool                `json:"priority"`
	Title    string              `json:"title"`
	Type     string              `json:"type"`
}

//  - This object contains meta data.
//
// resource: "lol-static-data", original name: "MetaDataDto"
type RuneMetadata struct {
	IsRune bool   `json:"isRune"`
	Tier   string `json:"tier"`
	Type   string `json:"type"`
}

//  - This object contains item tree data.
//
// resource: "lol-static-data", original name: "ItemTreeDto"
type ItemTree struct {
	Header string   `json:"header"`
	Tags   []string `json:"tags"`
}

//  - This object contains item group data.
//
// resource: "lol-static-data", original name: "GroupDto"
type ItemGroup struct {
	MaxGroupOwnable string `json:"MaxGroupOwnable"`
	Key             string `json:"key"`
}

//  - This object contains mastery tree list data.
//
// resource: "lol-static-data", original name: "MasteryTreeListDto"
type MasteryTrees struct {
	MasteryTreeItems []*MasteryTreeItem `json:"masteryTreeItems"`
}

//  - This object contains realm data.
//
// resource: "lol-static-data", original name: "RealmDto"
type Realm struct {
	// The base CDN url.
	Cdn string `json:"cdn"`
	// Latest changed version of Dragon Magic's css file.
	CSS string `json:"css"`
	// Latest changed version of Dragon Magic.
	Dd string `json:"dd"`
	// Default language for this realm.
	L string `json:"l"`
	// Legacy script mode for IE6 or older.
	Lg string `json:"lg"`
	// Latest changed version for each data type listed.
	N map[string]string `json:"n"`
	// Special behavior number identifying the largest profileicon id that can be used under 500. Any profileicon that is requested between this number and 500 should be mapped to 0.
	Profileiconmax int32 `json:"profileiconmax"`
	// Additional api data drawn from other sources that may be related to data dragon functionality.
	Store string `json:"store"`
	// Current version of this file for this realm.
	V string `json:"v"`
}

//  - This object contains rune list data.
//
// resource: "lol-static-data", original name: "RuneListDto"
type Runes struct {
	Basic   *BasicData       `json:"basic"`
	Data    map[string]*Rune `json:"data"`
	Type    string           `json:"type"`
	Version string           `json:"version"`
}

//  - This object contains mastery tree item data.
//
// resource: "lol-static-data", original name: "MasteryTreeItemDto"
type MasteryTreeItem struct {
	MasteryID int32  `json:"masteryId"`
	Prereq    string `json:"prereq"`
}

//  - This object contains spell vars data.
//
// resource: "lol-static-data", original name: "SpellVarsDto"
type SpellVars struct {
	Coeff     []float64 `json:"coeff"`
	Dyn       string    `json:"dyn"`
	Key       string    `json:"key"`
	Link      string    `json:"link"`
	RanksWith string    `json:"ranksWith"`
}

//  - This object contains champion passive data.
//
// resource: "lol-static-data", original name: "PassiveDto"
type Passive struct {
	Description          string `json:"description"`
	Image                *Image `json:"image"`
	Name                 string `json:"name"`
	SanitizedDescription string `json:"sanitizedDescription"`
}

//  - This object contains champion spell data.
//
// resource: "lol-static-data", original name: "ChampionSpellDto"
type ChampionSpell struct {
	Altimages    []*Image  `json:"altimages"`
	Cooldown     []float64 `json:"cooldown"`
	CooldownBurn string    `json:"cooldownBurn"`
	Cost         []int32   `json:"cost"`
	CostBurn     string    `json:"costBurn"`
	CostType     string    `json:"costType"`
	Description  string    `json:"description"`
	// This field is a List of List of Double.
	Effect     [][]float64 `json:"effect"`
	EffectBurn []string    `json:"effectBurn"`
	Image      *Image      `json:"image"`
	Key        string      `json:"key"`
	Leveltip   *LevelTip   `json:"leveltip"`
	Maxrank    int32       `json:"maxrank"`
	Name       string      `json:"name"`
	// This field is either a List of Integer or the String 'self' for spells that target one's own champion.
	Range                *SpellRange  `json:"range"`
	RangeBurn            string       `json:"rangeBurn"`
	Resource             string       `json:"resource"`
	SanitizedDescription string       `json:"sanitizedDescription"`
	SanitizedTooltip     string       `json:"sanitizedTooltip"`
	Tooltip              string       `json:"tooltip"`
	Vars                 []*SpellVars `json:"vars"`
}

//  - This object contains basic data stats.
//
// resource: "lol-static-data", original name: "BasicDataStatsDto"
type BasicStats struct {
	FlatArmorMod                        float64 `json:"FlatArmorMod"`
	FlatAttackSpeedMod                  float64 `json:"FlatAttackSpeedMod"`
	FlatBlockMod                        float64 `json:"FlatBlockMod"`
	FlatCritChanceMod                   float64 `json:"FlatCritChanceMod"`
	FlatCritDamageMod                   float64 `json:"FlatCritDamageMod"`
	FlatEXPBonus                        float64 `json:"FlatEXPBonus"`
	FlatEnergyPoolMod                   float64 `json:"FlatEnergyPoolMod"`
	FlatEnergyRegenMod                  float64 `json:"FlatEnergyRegenMod"`
	FlatHPPoolMod                       float64 `json:"FlatHPPoolMod"`
	FlatHPRegenMod                      float64 `json:"FlatHPRegenMod"`
	FlatMPPoolMod                       float64 `json:"FlatMPPoolMod"`
	FlatMPRegenMod                      float64 `json:"FlatMPRegenMod"`
	FlatMagicDamageMod                  float64 `json:"FlatMagicDamageMod"`
	FlatMovementSpeedMod                float64 `json:"FlatMovementSpeedMod"`
	FlatPhysicalDamageMod               float64 `json:"FlatPhysicalDamageMod"`
	FlatSpellBlockMod                   float64 `json:"FlatSpellBlockMod"`
	PercentArmorMod                     float64 `json:"PercentArmorMod"`
	PercentAttackSpeedMod               float64 `json:"PercentAttackSpeedMod"`
	PercentBlockMod                     float64 `json:"PercentBlockMod"`
	PercentCritChanceMod                float64 `json:"PercentCritChanceMod"`
	PercentCritDamageMod                float64 `json:"PercentCritDamageMod"`
	PercentDodgeMod                     float64 `json:"PercentDodgeMod"`
	PercentEXPBonus                     float64 `json:"PercentEXPBonus"`
	PercentHPPoolMod                    float64 `json:"PercentHPPoolMod"`
	PercentHPRegenMod                   float64 `json:"PercentHPRegenMod"`
	PercentLifeStealMod                 float64 `json:"PercentLifeStealMod"`
	PercentMPPoolMod                    float64 `json:"PercentMPPoolMod"`
	PercentMPRegenMod                   float64 `json:"PercentMPRegenMod"`
	PercentMagicDamageMod               float64 `json:"PercentMagicDamageMod"`
	PercentMovementSpeedMod             float64 `json:"PercentMovementSpeedMod"`
	PercentPhysicalDamageMod            float64 `json:"PercentPhysicalDamageMod"`
	PercentSpellBlockMod                float64 `json:"PercentSpellBlockMod"`
	PercentSpellVampMod                 float64 `json:"PercentSpellVampMod"`
	RFlatArmorModPerLevel               float64 `json:"rFlatArmorModPerLevel"`
	RFlatArmorPenetrationMod            float64 `json:"rFlatArmorPenetrationMod"`
	RFlatArmorPenetrationModPerLevel    float64 `json:"rFlatArmorPenetrationModPerLevel"`
	RFlatCritChanceModPerLevel          float64 `json:"rFlatCritChanceModPerLevel"`
	RFlatCritDamageModPerLevel          float64 `json:"rFlatCritDamageModPerLevel"`
	RFlatDodgeMod                       float64 `json:"rFlatDodgeMod"`
	RFlatDodgeModPerLevel               float64 `json:"rFlatDodgeModPerLevel"`
	RFlatEnergyModPerLevel              float64 `json:"rFlatEnergyModPerLevel"`
	RFlatEnergyRegenModPerLevel         float64 `json:"rFlatEnergyRegenModPerLevel"`
	RFlatGoldPer10Mod                   float64 `json:"rFlatGoldPer10Mod"`
	RFlatHPModPerLevel                  float64 `json:"rFlatHPModPerLevel"`
	RFlatHPRegenModPerLevel             float64 `json:"rFlatHPRegenModPerLevel"`
	RFlatMPModPerLevel                  float64 `json:"rFlatMPModPerLevel"`
	RFlatMPRegenModPerLevel             float64 `json:"rFlatMPRegenModPerLevel"`
	RFlatMagicDamageModPerLevel         float64 `json:"rFlatMagicDamageModPerLevel"`
	RFlatMagicPenetrationMod            float64 `json:"rFlatMagicPenetrationMod"`
	RFlatMagicPenetrationModPerLevel    float64 `json:"rFlatMagicPenetrationModPerLevel"`
	RFlatMovementSpeedModPerLevel       float64 `json:"rFlatMovementSpeedModPerLevel"`
	RFlatPhysicalDamageModPerLevel      float64 `json:"rFlatPhysicalDamageModPerLevel"`
	RFlatSpellBlockModPerLevel          float64 `json:"rFlatSpellBlockModPerLevel"`
	RFlatTimeDeadMod                    float64 `json:"rFlatTimeDeadMod"`
	RFlatTimeDeadModPerLevel            float64 `json:"rFlatTimeDeadModPerLevel"`
	RPercentArmorPenetrationMod         float64 `json:"rPercentArmorPenetrationMod"`
	RPercentArmorPenetrationModPerLevel float64 `json:"rPercentArmorPenetrationModPerLevel"`
	RPercentAttackSpeedModPerLevel      float64 `json:"rPercentAttackSpeedModPerLevel"`
	RPercentCooldownMod                 float64 `json:"rPercentCooldownMod"`
	RPercentCooldownModPerLevel         float64 `json:"rPercentCooldownModPerLevel"`
	RPercentMagicPenetrationMod         float64 `json:"rPercentMagicPenetrationMod"`
	RPercentMagicPenetrationModPerLevel float64 `json:"rPercentMagicPenetrationModPerLevel"`
	RPercentMovementSpeedModPerLevel    float64 `json:"rPercentMovementSpeedModPerLevel"`
	RPercentTimeDeadMod                 float64 `json:"rPercentTimeDeadMod"`
	RPercentTimeDeadModPerLevel         float64 `json:"rPercentTimeDeadModPerLevel"`
}

//  - This object contains item data.
//
// resource: "lol-static-data", original name: "ItemDto"
type Item struct {
	Colloq        string            `json:"colloq"`
	ConsumeOnFull bool              `json:"consumeOnFull"`
	Consumed      bool              `json:"consumed"`
	Depth         int32             `json:"depth"`
	Description   string            `json:"description"`
	Effect        map[string]string `json:"effect"`
	From          []string          `json:"from"`
	// Data Dragon includes the gold field for basic data, which is shared by both rune and item. However, only items have a gold field on them, representing their gold cost in the store. Since runes are not sold in the store, they have no gold cost.
	Gold                 *Gold           `json:"gold"`
	Group                string          `json:"group"`
	HideFromAll          bool            `json:"hideFromAll"`
	ID                   int32           `json:"id"`
	Image                *Image          `json:"image"`
	InStore              bool            `json:"inStore"`
	Into                 []string        `json:"into"`
	Maps                 map[string]bool `json:"maps"`
	Name                 string          `json:"name"`
	Plaintext            string          `json:"plaintext"`
	RequiredChampion     string          `json:"requiredChampion"`
	Rune                 *RuneMetadata   `json:"rune"`
	SanitizedDescription string          `json:"sanitizedDescription"`
	SpecialRecipe        int32           `json:"specialRecipe"`
	Stacks               int32           `json:"stacks"`
	Stats                *BasicStats     `json:"stats"`
	Tags                 []string        `json:"tags"`
}

//  - This object contains champion recommended block data.
//
// resource: "lol-static-data", original name: "BlockDto"
type RecommendedBlock struct {
	Items   []*RecommendedItems `json:"items"`
	RecMath bool                `json:"recMath"`
	Type    string              `json:"type"`
}

//  - This object contains champion list data.
//
// resource: "lol-static-data", original name: "ChampionListDto"
type Champions struct {
	Data    map[string]*Champion `json:"data"`
	Format  string               `json:"format"`
	Keys    map[string]string    `json:"keys"`
	Type    string               `json:"type"`
	Version string               `json:"version"`
}

//  - This object contains mastery tree data.
//
// resource: "lol-static-data", original name: "MasteryTreeDto"
type MasteryTree struct {
	Cunning  []*MasteryTrees `json:"Cunning"`
	Ferocity []*MasteryTrees `json:"Ferocity"`
	Resolve  []*MasteryTrees `json:"Resolve"`
}

//  - This object contains image data.
//
// resource: "lol-static-data", original name: "ImageDto"
type Image struct {
	Full   string `json:"full"`
	Group  string `json:"group"`
	H      int32  `json:"h"`
	Sprite string `json:"sprite"`
	W      int32  `json:"w"`
	X      int32  `json:"x"`
	Y      int32  `json:"y"`
}

//  - This object contains map details data.
//
// resource: "lol-static-data", original name: "MapDetailsDto"
type Map struct {
	Image                 *Image  `json:"image"`
	MapID                 int64   `json:"mapId"`
	MapName               string  `json:"mapName"`
	UnpurchasableItemList []int64 `json:"unpurchasableItemList"`
}

//  - This object contains summoner spell list data.
//
// resource: "lol-static-data", original name: "SummonerSpellListDto"
type SummonerSpells struct {
	Data    map[string]*SummonerSpell `json:"data"`
	Type    string                    `json:"type"`
	Version string                    `json:"version"`
}

//  - This object contains champion skin data.
//
// resource: "lol-static-data", original name: "SkinDto"
type Skin struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
	Num  int32  `json:"num"`
}

//  - This object contains champion information.
//
// resource: "lol-static-data", original name: "InfoDto"
type ChampionInfo struct {
	Attack     int32 `json:"attack"`
	Defense    int32 `json:"defense"`
	Difficulty int32 `json:"difficulty"`
	Magic      int32 `json:"magic"`
}

//  - This object contains champion data.
//
// resource: "lol-static-data", original name: "ChampionDto"
type Champion struct {
	Allytips    []string         `json:"allytips"`
	Blurb       string           `json:"blurb"`
	Enemytips   []string         `json:"enemytips"`
	ID          int32            `json:"id"`
	Image       *Image           `json:"image"`
	Info        *ChampionInfo    `json:"info"`
	Key         string           `json:"key"`
	Lore        string           `json:"lore"`
	Name        string           `json:"name"`
	Partype     string           `json:"partype"`
	Passive     *Passive         `json:"passive"`
	Recommended []*Recommended   `json:"recommended"`
	Skins       []*Skin          `json:"skins"`
	Spells      []*ChampionSpell `json:"spells"`
	Stats       *ChampionStats   `json:"stats"`
	Tags        []string         `json:"tags"`
	Title       string           `json:"title"`
}

//  - This object contains basic data.
//
// resource: "lol-static-data", original name: "BasicDataDto"
type BasicData struct {
	Colloq        string   `json:"colloq"`
	ConsumeOnFull bool     `json:"consumeOnFull"`
	Consumed      bool     `json:"consumed"`
	Depth         int32    `json:"depth"`
	Description   string   `json:"description"`
	From          []string `json:"from"`
	// Data Dragon includes the gold field for basic data, which is shared by both rune and item. However, only items have a gold field on them, representing their gold cost in the store. Since runes are not sold in the store, they have no gold cost.
	Gold                 *Gold           `json:"gold"`
	Group                string          `json:"group"`
	HideFromAll          bool            `json:"hideFromAll"`
	ID                   int32           `json:"id"`
	Image                *Image          `json:"image"`
	InStore              bool            `json:"inStore"`
	Into                 []string        `json:"into"`
	Maps                 map[string]bool `json:"maps"`
	Name                 string          `json:"name"`
	Plaintext            string          `json:"plaintext"`
	RequiredChampion     string          `json:"requiredChampion"`
	Rune                 *RuneMetadata   `json:"rune"`
	SanitizedDescription string          `json:"sanitizedDescription"`
	SpecialRecipe        int32           `json:"specialRecipe"`
	Stacks               int32           `json:"stacks"`
	Stats                *BasicStats     `json:"stats"`
	Tags                 []string        `json:"tags"`
}

//  - This object contains mastery list data.
//
// resource: "lol-static-data", original name: "MasteryListDto"
type Masteries struct {
	Data    map[string]*Mastery `json:"data"`
	Tree    *MasteryTree        `json:"tree"`
	Type    string              `json:"type"`
	Version string              `json:"version"`
}

//  - This object contains summoner spell data.
//
// resource: "lol-static-data", original name: "SummonerSpellDto"
type SummonerSpell struct {
	Cooldown     []float64 `json:"cooldown"`
	CooldownBurn string    `json:"cooldownBurn"`
	Cost         []int32   `json:"cost"`
	CostBurn     string    `json:"costBurn"`
	CostType     string    `json:"costType"`
	Description  string    `json:"description"`
	// This field is a List of List of Double.
	Effect     [][]float64 `json:"effect"`
	EffectBurn []string    `json:"effectBurn"`
	ID         int32       `json:"id"`
	Image      *Image      `json:"image"`
	Key        string      `json:"key"`
	Leveltip   *LevelTip   `json:"leveltip"`
	Maxrank    int32       `json:"maxrank"`
	Modes      []string    `json:"modes"`
	Name       string      `json:"name"`
	// This field is either a List of Integer or the String 'self' for spells that target one's own champion.
	Range                *SpellRange  `json:"range"`
	RangeBurn            string       `json:"rangeBurn"`
	Resource             string       `json:"resource"`
	SanitizedDescription string       `json:"sanitizedDescription"`
	SanitizedTooltip     string       `json:"sanitizedTooltip"`
	SummonerLevel        int32        `json:"summonerLevel"`
	Tooltip              string       `json:"tooltip"`
	Vars                 []*SpellVars `json:"vars"`
}

//  - This object contains champion stats data.
//
// resource: "lol-static-data", original name: "StatsDto"
type ChampionStats struct {
	Armor                float64 `json:"armor"`
	Armorperlevel        float64 `json:"armorperlevel"`
	Attackdamage         float64 `json:"attackdamage"`
	Attackdamageperlevel float64 `json:"attackdamageperlevel"`
	Attackrange          float64 `json:"attackrange"`
	Attackspeedoffset    float64 `json:"attackspeedoffset"`
	Attackspeedperlevel  float64 `json:"attackspeedperlevel"`
	Crit                 float64 `json:"crit"`
	Critperlevel         float64 `json:"critperlevel"`
	Hp                   float64 `json:"hp"`
	Hpperlevel           float64 `json:"hpperlevel"`
	Hpregen              float64 `json:"hpregen"`
	Hpregenperlevel      float64 `json:"hpregenperlevel"`
	Movespeed            float64 `json:"movespeed"`
	Mp                   float64 `json:"mp"`
	Mpperlevel           float64 `json:"mpperlevel"`
	Mpregen              float64 `json:"mpregen"`
	Mpregenperlevel      float64 `json:"mpregenperlevel"`
	Spellblock           float64 `json:"spellblock"`
	Spellblockperlevel   float64 `json:"spellblockperlevel"`
}

//  - This object contains item gold data.
//
// resource: "lol-static-data", original name: "GoldDto"
type Gold struct {
	Base        int32 `json:"base"`
	Purchasable bool  `json:"purchasable"`
	Sell        int32 `json:"sell"`
	Total       int32 `json:"total"`
}

//  - This object contains language strings data.
//
// resource: "lol-static-data", original name: "LanguageStringsDto"
type LanguageStrings struct {
	Data    map[string]string `json:"data"`
	Type    string            `json:"type"`
	Version string            `json:"version"`
}

//  - This object contains map data.
//
// resource: "lol-static-data", original name: "MapDataDto"
type Maps struct {
	Data    map[string]*Map `json:"data"`
	Type    string          `json:"type"`
	Version string          `json:"version"`
}

//  - This object contains mastery data.
//
// resource: "lol-static-data", original name: "MasteryDto"
type Mastery struct {
	Description []string `json:"description"`
	ID          int32    `json:"id"`
	Image       *Image   `json:"image"`
	// Legal values: Cunning, Ferocity, Resolve
	MasteryTree          string   `json:"masteryTree"`
	Name                 string   `json:"name"`
	Prereq               string   `json:"prereq"`
	Ranks                int32    `json:"ranks"`
	SanitizedDescription []string `json:"sanitizedDescription"`
}

// ShardsCall is a builder for StaticClient.Shards
type ShardsCall struct {
	ctx        context.Context
	client     StaticClient
	query      url.Values
	pathParams map[string]string
}

// Get shard list. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://status.leagueoflegends.com/shards
func (c StaticClient) Shards(ctx context.Context) *ShardsCall {
	path := make(map[string]string)
	return &ShardsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path}
}

func (c *ShardsCall) doRequest() (*http.Response, error) {
	var body io.Reader

	path, err := uritemplates.Expand("/shards", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://status.leagueoflegends.com" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ShardsCall) Do() ([]*Shard, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make([]*Shard, 0)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// ShardCall is a builder for StaticClient.Shard
type ShardCall struct {
	ctx        context.Context
	client     StaticClient
	query      url.Values
	pathParams map[string]string
}

// Get shard status. Returns the data available on the status.leagueoflegends.com website for the given region. (REST)
//
//
// Rate limit notes: Requests to this API will not be counted in your Rate Limit.
//
//    GET: https://status.leagueoflegends.com/shards/{shard}
func (c StaticClient) Shard(ctx context.Context, shard string) *ShardCall {
	path := make(map[string]string)
	path["shard"] = convertToString(shard)
	return &ShardCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path}
}

func (c *ShardCall) doRequest() (*http.Response, error) {
	var body io.Reader

	path, err := uritemplates.Expand("/shards/{shard}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := "https://status.leagueoflegends.com" + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *ShardCall) Do() (*ShardStatus, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &ShardStatus{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// resource: "lol-status", original name: "Message"
type StatusMessage struct {
	Author       string                      `json:"author"`
	Content      string                      `json:"content"`
	CreatedAt    string                      `json:"created_at"`
	ID           string                      `json:"id"`
	Severity     string                      `json:"severity"`
	Translations []*StatusMessageTranslation `json:"translations"`
	UpdatedAt    string                      `json:"updated_at"`
}

// resource: "lol-status", original name: "Incident"
type Incident struct {
	Active    bool             `json:"active"`
	CreatedAt string           `json:"created_at"`
	ID        int64            `json:"id"`
	Updates   []*StatusMessage `json:"updates"`
}

// resource: "lol-status", original name: "Service"
type Service struct {
	Incidents []*Incident `json:"incidents"`
	Name      string      `json:"name"`
	Slug      string      `json:"slug"`
	Status    string      `json:"status"`
}

// resource: "lol-status", original name: "ShardStatus"
type ShardStatus struct {
	Hostname  string     `json:"hostname"`
	Locales   []string   `json:"locales"`
	Name      string     `json:"name"`
	RegionTag string     `json:"region_tag"`
	Services  []*Service `json:"services"`
	Slug      string     `json:"slug"`
}

// resource: "lol-status", original name: "Shard"
type Shard struct {
	Hostname  string   `json:"hostname"`
	Locales   []string `json:"locales"`
	Name      string   `json:"name"`
	RegionTag string   `json:"region_tag"`
	Slug      string   `json:"slug"`
}

// resource: "lol-status", original name: "Translation"
type StatusMessageTranslation struct {
	Content   string `json:"content"`
	Locale    string `json:"locale"`
	UpdatedAt string `json:"updated_at"`
}

// MatchesByTournementCall is a builder for Client.MatchesByTournement
type MatchesByTournementCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve match IDs by tournament code. (REST)
//
//
//    GET: /api/lol/{region}/v2.2/match/by-tournament/{tournamentCode}/ids
func (c Client) MatchesByTournement(ctx context.Context, region Region, tournamentCode string) *MatchesByTournementCall {
	path := make(map[string]string)
	path["tournamentCode"] = convertToString(tournamentCode)
	return &MatchesByTournementCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *MatchesByTournementCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.2/match/by-tournament/{tournamentCode}/ids", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MatchesByTournementCall) Do() ([]int64, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make([]int64, 0)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// MatchForTournementCall is a builder for Client.MatchForTournement
type MatchForTournementCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve match by match ID and tournament code. (REST)
//
//
//    GET: /api/lol/{region}/v2.2/match/for-tournament/{matchId}
func (c Client) MatchForTournement(ctx context.Context, region Region, matchId int64) *MatchForTournementCall {
	path := make(map[string]string)
	path["matchId"] = convertToString(matchId)
	return &MatchForTournementCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *MatchForTournementCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.2/match/for-tournament/{matchId}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MatchForTournementCall) Do() (*MatchDetail, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &MatchDetail{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// MatchCall is a builder for Client.Match
type MatchCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve match by match ID. (REST)
//
//
// Implementation notes: Not all matches have timeline data. If timeline data is requested, but doesn't exist, then the response won't include it.
//
//    GET: /api/lol/{region}/v2.2/match/{matchId}
func (c Client) Match(ctx context.Context, region Region, matchId int64) *MatchCall {
	path := make(map[string]string)
	path["matchId"] = convertToString(matchId)
	return &MatchCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *MatchCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.2/match/{matchId}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MatchCall) Do() (*MatchDetail, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &MatchDetail{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains match player information
//
// resource: "match", original name: "Player"
type Player struct {
	// Match history URI
	MatchHistoryURI string `json:"matchHistoryUri"`
	// Profile icon ID
	ProfileIcon int32 `json:"profileIcon"`
	// Summoner ID
	SummonerID int64 `json:"summonerId"`
	// Summoner name
	SummonerName string `json:"summonerName"`
}

//  - This object contains mastery information
//
// resource: "match", original name: "Mastery"
type UsedMastery struct {
	// Mastery ID
	MasteryID int64 `json:"masteryId"`
	// Mastery rank
	Rank int64 `json:"rank"`
}

//  - This object contains game timeline information
//
// resource: "match", original name: "Timeline"
type Timeline struct {
	// Time between each returned frame in milliseconds.
	FrameInterval int64 `json:"frameInterval"`
	// List of timeline frames for the game.
	Frames []*Frame `json:"frames"`
}

//  - This object contains match participant information
//
// resource: "match", original name: "Participant"
type Participant struct {
	// Champion ID
	ChampionID int32 `json:"championId"`
	// Highest ranked tier achieved for the previous season, if any, otherwise null. Used to display border in game loading screen. (Legal values: CHALLENGER, MASTER, DIAMOND, PLATINUM, GOLD, SILVER, BRONZE, UNRANKED)
	HighestAchievedSeasonTier string `json:"highestAchievedSeasonTier"`
	// List of mastery information
	Masteries []*UsedMastery `json:"masteries"`
	// Participant ID
	ParticipantID int32 `json:"participantId"`
	// List of rune information
	Runes []*UsedRune `json:"runes"`
	// First summoner spell ID
	Spell1Id int32 `json:"spell1Id"`
	// Second summoner spell ID
	Spell2Id int32 `json:"spell2Id"`
	// Participant statistics
	Stats *ParticipantStats `json:"stats"`
	// Team ID
	TeamID int32 `json:"teamId"`
	// Timeline data. Delta fields refer to values for the specified period (e.g., the gold per minute over the first 10 minutes of the game versus the second 20 minutes of the game. Diffs fields refer to the deltas versus the calculated lane opponent(s).
	Timeline *ParticipantTimeline `json:"timeline"`
}

//  - This object contains match detail information
//
// resource: "match", original name: "MatchDetail"
type MatchDetail struct {
	// Match map ID
	MapID int32 `json:"mapId"`
	// Match creation time. Designates when the team select lobby is created and/or the match is made through match making, not when the game actually starts.
	MatchCreation int64 `json:"matchCreation"`
	// Match duration
	MatchDuration int64 `json:"matchDuration"`
	// ID of the match
	MatchID int64 `json:"matchId"`
	// Match mode (Legal values: CLASSIC, ODIN, ARAM, TUTORIAL, ONEFORALL, ASCENSION, FIRSTBLOOD, KINGPORO)
	MatchMode string `json:"matchMode"`
	// Match type (Legal values: CUSTOM_GAME, MATCHED_GAME, TUTORIAL_GAME)
	MatchType string `json:"matchType"`
	// Match version
	MatchVersion string `json:"matchVersion"`
	// Participant identity information
	ParticipantIdentities []*ParticipantIdentity `json:"participantIdentities"`
	// Participant information
	Participants []*Participant `json:"participants"`
	// Platform ID of the match
	PlatformID string `json:"platformId"`
	// Match queue type (Legal values: CUSTOM, NORMAL_5x5_BLIND, RANKED_SOLO_5x5, RANKED_PREMADE_5x5, BOT_5x5, NORMAL_3x3, RANKED_PREMADE_3x3, NORMAL_5x5_DRAFT, ODIN_5x5_BLIND, ODIN_5x5_DRAFT, BOT_ODIN_5x5, BOT_5x5_INTRO, BOT_5x5_BEGINNER, BOT_5x5_INTERMEDIATE, RANKED_TEAM_3x3, RANKED_TEAM_5x5, BOT_TT_3x3, GROUP_FINDER_5x5, ARAM_5x5, ONEFORALL_5x5, FIRSTBLOOD_1x1, FIRSTBLOOD_2x2, SR_6x6, URF_5x5, ONEFORALL_MIRRORMODE_5x5, BOT_URF_5x5, NIGHTMARE_BOT_5x5_RANK1, NIGHTMARE_BOT_5x5_RANK2, NIGHTMARE_BOT_5x5_RANK5, ASCENSION_5x5, HEXAKILL, BILGEWATER_ARAM_5x5, KING_PORO_5x5, COUNTER_PICK, BILGEWATER_5x5, TEAM_BUILDER_DRAFT_UNRANKED_5x5, TEAM_BUILDER_DRAFT_RANKED_5x5)
	QueueType string `json:"queueType"`
	// Region where the match was played
	Region string `json:"region"`
	// Season match was played (Legal values: PRESEASON3, SEASON3, PRESEASON2014, SEASON2014, PRESEASON2015, SEASON2015, PRESEASON2016, SEASON2016)
	Season string `json:"season"`
	// Team information
	Teams []*MatchTeam `json:"teams"`
	// Match timeline data (not included by default)
	Timeline *Timeline `json:"timeline"`
}

//  - This object contains participant frame position information
//
// resource: "match", original name: "Position"
type Position struct {
	X int32 `json:"x"`
	Y int32 `json:"y"`
}

//  - This object contains information about banned champions
//
// resource: "match", original name: "BannedChampion"
type BannedChampion struct {
	// Banned champion ID
	ChampionID int32 `json:"championId"`
	// Turn during which the champion was banned
	PickTurn int32 `json:"pickTurn"`
}

//  - This object contains all timeline information
//
// resource: "match", original name: "ParticipantTimeline"
type ParticipantTimeline struct {
	// Ancient golem assists per minute timeline counts
	AncientGolemAssistsPerMinCounts *ParticipantTimelineData `json:"ancientGolemAssistsPerMinCounts"`
	// Ancient golem kills per minute timeline counts
	AncientGolemKillsPerMinCounts *ParticipantTimelineData `json:"ancientGolemKillsPerMinCounts"`
	// Assisted lane deaths per minute timeline data
	AssistedLaneDeathsPerMinDeltas *ParticipantTimelineData `json:"assistedLaneDeathsPerMinDeltas"`
	// Assisted lane kills per minute timeline data
	AssistedLaneKillsPerMinDeltas *ParticipantTimelineData `json:"assistedLaneKillsPerMinDeltas"`
	// Baron assists per minute timeline counts
	BaronAssistsPerMinCounts *ParticipantTimelineData `json:"baronAssistsPerMinCounts"`
	// Baron kills per minute timeline counts
	BaronKillsPerMinCounts *ParticipantTimelineData `json:"baronKillsPerMinCounts"`
	// Creeps per minute timeline data
	CreepsPerMinDeltas *ParticipantTimelineData `json:"creepsPerMinDeltas"`
	// Creep score difference per minute timeline data
	CsDiffPerMinDeltas *ParticipantTimelineData `json:"csDiffPerMinDeltas"`
	// Damage taken difference per minute timeline data
	DamageTakenDiffPerMinDeltas *ParticipantTimelineData `json:"damageTakenDiffPerMinDeltas"`
	// Damage taken per minute timeline data
	DamageTakenPerMinDeltas *ParticipantTimelineData `json:"damageTakenPerMinDeltas"`
	// Dragon assists per minute timeline counts
	DragonAssistsPerMinCounts *ParticipantTimelineData `json:"dragonAssistsPerMinCounts"`
	// Dragon kills per minute timeline counts
	DragonKillsPerMinCounts *ParticipantTimelineData `json:"dragonKillsPerMinCounts"`
	// Elder lizard assists per minute timeline counts
	ElderLizardAssistsPerMinCounts *ParticipantTimelineData `json:"elderLizardAssistsPerMinCounts"`
	// Elder lizard kills per minute timeline counts
	ElderLizardKillsPerMinCounts *ParticipantTimelineData `json:"elderLizardKillsPerMinCounts"`
	// Gold per minute timeline data
	GoldPerMinDeltas *ParticipantTimelineData `json:"goldPerMinDeltas"`
	// Inhibitor assists per minute timeline counts
	InhibitorAssistsPerMinCounts *ParticipantTimelineData `json:"inhibitorAssistsPerMinCounts"`
	// Inhibitor kills per minute timeline counts
	InhibitorKillsPerMinCounts *ParticipantTimelineData `json:"inhibitorKillsPerMinCounts"`
	// Participant's lane (Legal values: MID, MIDDLE, TOP, JUNGLE, BOT, BOTTOM)
	Lane string `json:"lane"`
	// Participant's role (Legal values: DUO, NONE, SOLO, DUO_CARRY, DUO_SUPPORT)
	Role string `json:"role"`
	// Tower assists per minute timeline counts
	TowerAssistsPerMinCounts *ParticipantTimelineData `json:"towerAssistsPerMinCounts"`
	// Tower kills per minute timeline counts
	TowerKillsPerMinCounts *ParticipantTimelineData `json:"towerKillsPerMinCounts"`
	// Tower kills per minute timeline data
	TowerKillsPerMinDeltas *ParticipantTimelineData `json:"towerKillsPerMinDeltas"`
	// Vilemaw assists per minute timeline counts
	VilemawAssistsPerMinCounts *ParticipantTimelineData `json:"vilemawAssistsPerMinCounts"`
	// Vilemaw kills per minute timeline counts
	VilemawKillsPerMinCounts *ParticipantTimelineData `json:"vilemawKillsPerMinCounts"`
	// Wards placed per minute timeline data
	WardsPerMinDeltas *ParticipantTimelineData `json:"wardsPerMinDeltas"`
	// Experience difference per minute timeline data
	XpDiffPerMinDeltas *ParticipantTimelineData `json:"xpDiffPerMinDeltas"`
	// Experience per minute timeline data
	XpPerMinDeltas *ParticipantTimelineData `json:"xpPerMinDeltas"`
}

//  - This object contains participant frame information
//
// resource: "match", original name: "ParticipantFrame"
type ParticipantFrame struct {
	// Participant's current gold
	CurrentGold int32 `json:"currentGold"`
	// Dominion score of the participant
	DominionScore int32 `json:"dominionScore"`
	// Number of jungle minions killed by participant
	JungleMinionsKilled int32 `json:"jungleMinionsKilled"`
	// Participant's current level
	Level int32 `json:"level"`
	// Number of minions killed by participant
	MinionsKilled int32 `json:"minionsKilled"`
	// Participant ID
	ParticipantID int32 `json:"participantId"`
	// Participant's position
	Position *Position `json:"position"`
	// Team score of the participant
	TeamScore int32 `json:"teamScore"`
	// Participant's total gold
	TotalGold int32 `json:"totalGold"`
	// Experience earned by participant
	Xp int32 `json:"xp"`
}

//  - This object contains timeline data
//
// resource: "match", original name: "ParticipantTimelineData"
type ParticipantTimelineData struct {
	// Value per minute from 10 min to 20 min
	TenToTwenty float64 `json:"tenToTwenty"`
	// Value per minute from 30 min to the end of the game
	ThirtyToEnd float64 `json:"thirtyToEnd"`
	// Value per minute from 20 min to 30 min
	TwentyToThirty float64 `json:"twentyToThirty"`
	// Value per minute from the beginning of the game to 10 min
	ZeroToTen float64 `json:"zeroToTen"`
}

//  - This object contains game frame information
//
// resource: "match", original name: "Frame"
type Frame struct {
	// List of events for this frame.
	Events []*Event `json:"events"`
	// Map of each participant ID to the participant's information for the frame.
	ParticipantFrames map[string]*ParticipantFrame `json:"participantFrames"`
	// Represents how many milliseconds into the game the frame occurred.
	Timestamp int64 `json:"timestamp"`
}

//  - This object contains team information
//
// resource: "match", original name: "Team"
type MatchTeam struct {
	// If game was draft mode, contains banned champion data, otherwise null
	Bans []*BannedChampion `json:"bans"`
	// Number of times the team killed baron
	BaronKills int32 `json:"baronKills"`
	// If game was a dominion game, specifies the points the team had at game end, otherwise null
	DominionVictoryScore int64 `json:"dominionVictoryScore"`
	// Number of times the team killed dragon
	DragonKills int32 `json:"dragonKills"`
	// Flag indicating whether or not the team got the first baron kill
	FirstBaron bool `json:"firstBaron"`
	// Flag indicating whether or not the team got first blood
	FirstBlood bool `json:"firstBlood"`
	// Flag indicating whether or not the team got the first dragon kill
	FirstDragon bool `json:"firstDragon"`
	// Flag indicating whether or not the team destroyed the first inhibitor
	FirstInhibitor bool `json:"firstInhibitor"`
	// Flag indicating whether or not the team got the first rift herald kill
	FirstRiftHerald bool `json:"firstRiftHerald"`
	// Flag indicating whether or not the team destroyed the first tower
	FirstTower bool `json:"firstTower"`
	// Number of inhibitors the team destroyed
	InhibitorKills int32 `json:"inhibitorKills"`
	// Number of times the team killed rift herald
	RiftHeraldKills int32 `json:"riftHeraldKills"`
	// Team ID
	TeamID int32 `json:"teamId"`
	// Number of towers the team destroyed
	TowerKills int32 `json:"towerKills"`
	// Number of times the team killed vilemaw
	VilemawKills int32 `json:"vilemawKills"`
	// Flag indicating whether or not the team won
	Winner bool `json:"winner"`
}

//  - This object contains participant identity information
//
// resource: "match", original name: "ParticipantIdentity"
type ParticipantIdentity struct {
	// Participant ID
	ParticipantID int32 `json:"participantId"`
	// Player information
	Player *Player `json:"player"`
}

//  - This object contains game event information. Note that not all legal type values documented below are valid for all games. Event data evolves over time and certain values may be relevant only for older or newer games.
//
// resource: "match", original name: "Event"
type Event struct {
	// The ascended type of the event. Only present if relevant. Note that CLEAR_ASCENDED refers to when a participants kills the ascended player. (Legal values: CHAMPION_ASCENDED, CLEAR_ASCENDED, MINION_ASCENDED)
	AscendedType string `json:"ascendedType"`
	// The assisting participant IDs of the event. Only present if relevant.
	AssistingParticipantIds []int32 `json:"assistingParticipantIds"`
	// The building type of the event. Only present if relevant. (Legal values: INHIBITOR_BUILDING, TOWER_BUILDING)
	BuildingType string `json:"buildingType"`
	// The creator ID of the event. Only present if relevant.
	CreatorID int32 `json:"creatorId"`
	// Event type. (Legal values: ASCENDED_EVENT, BUILDING_KILL, CAPTURE_POINT, CHAMPION_KILL, ELITE_MONSTER_KILL, ITEM_DESTROYED, ITEM_PURCHASED, ITEM_SOLD, ITEM_UNDO, PORO_KING_SUMMON, SKILL_LEVEL_UP, WARD_KILL, WARD_PLACED)
	EventType string `json:"eventType"`
	// The ending item ID of the event. Only present if relevant.
	ItemAfter int32 `json:"itemAfter"`
	// The starting item ID of the event. Only present if relevant.
	ItemBefore int32 `json:"itemBefore"`
	// The item ID of the event. Only present if relevant.
	ItemID int32 `json:"itemId"`
	// The killer ID of the event. Only present if relevant. Killer ID 0 indicates a minion.
	KillerID int32 `json:"killerId"`
	// The lane type of the event. Only present if relevant. (Legal values: BOT_LANE, MID_LANE, TOP_LANE)
	LaneType string `json:"laneType"`
	// The level up type of the event. Only present if relevant. (Legal values: EVOLVE, NORMAL)
	LevelUpType string `json:"levelUpType"`
	// The monster type of the event. Only present if relevant. (Legal values: BARON_NASHOR, BLUE_GOLEM, DRAGON, RED_LIZARD, RIFTHERALD, VILEMAW)
	MonsterType string `json:"monsterType"`
	// The participant ID of the event. Only present if relevant.
	ParticipantID int32 `json:"participantId"`
	// The point captured in the event. Only present if relevant. (Legal values: POINT_A, POINT_B, POINT_C, POINT_D, POINT_E)
	PointCaptured string `json:"pointCaptured"`
	// The position of the event. Only present if relevant.
	Position *Position `json:"position"`
	// The skill slot of the event. Only present if relevant.
	SkillSlot int32 `json:"skillSlot"`
	// The team ID of the event. Only present if relevant.
	TeamID int32 `json:"teamId"`
	// Represents how many milliseconds into the game the event occurred.
	Timestamp int64 `json:"timestamp"`
	// The tower type of the event. Only present if relevant. (Legal values: BASE_TURRET, FOUNTAIN_TURRET, INNER_TURRET, NEXUS_TURRET, OUTER_TURRET, UNDEFINED_TURRET)
	TowerType string `json:"towerType"`
	// The victim ID of the event. Only present if relevant.
	VictimID int32 `json:"victimId"`
	// The ward type of the event. Only present if relevant. (Legal values: BLUE_TRINKET, SIGHT_WARD, TEEMO_MUSHROOM, UNDEFINED, VISION_WARD, YELLOW_TRINKET, YELLOW_TRINKET_UPGRADE)
	WardType string `json:"wardType"`
}

//  - This object contains rune information
//
// resource: "match", original name: "Rune"
type UsedRune struct {
	// Rune rank
	Rank int64 `json:"rank"`
	// Rune ID
	RuneID int64 `json:"runeId"`
}

//  - This object contains participant statistics information
//
// resource: "match", original name: "ParticipantStats"
type ParticipantStats struct {
	// Number of assists
	Assists int64 `json:"assists"`
	// Champion level achieved
	ChampLevel int64 `json:"champLevel"`
	// If game was a dominion game, player's combat score, otherwise 0
	CombatPlayerScore int64 `json:"combatPlayerScore"`
	// Number of deaths
	Deaths int64 `json:"deaths"`
	// Number of double kills
	DoubleKills int64 `json:"doubleKills"`
	// Flag indicating if participant got an assist on first blood
	FirstBloodAssist bool `json:"firstBloodAssist"`
	// Flag indicating if participant got first blood
	FirstBloodKill bool `json:"firstBloodKill"`
	// Flag indicating if participant got an assist on the first inhibitor
	FirstInhibitorAssist bool `json:"firstInhibitorAssist"`
	// Flag indicating if participant destroyed the first inhibitor
	FirstInhibitorKill bool `json:"firstInhibitorKill"`
	// Flag indicating if participant got an assist on the first tower
	FirstTowerAssist bool `json:"firstTowerAssist"`
	// Flag indicating if participant destroyed the first tower
	FirstTowerKill bool `json:"firstTowerKill"`
	// Gold earned
	GoldEarned int64 `json:"goldEarned"`
	// Gold spent
	GoldSpent int64 `json:"goldSpent"`
	// Number of inhibitor kills
	InhibitorKills int64 `json:"inhibitorKills"`
	// First item ID
	Item0 int64 `json:"item0"`
	// Second item ID
	Item1 int64 `json:"item1"`
	// Third item ID
	Item2 int64 `json:"item2"`
	// Fourth item ID
	Item3 int64 `json:"item3"`
	// Fifth item ID
	Item4 int64 `json:"item4"`
	// Sixth item ID
	Item5 int64 `json:"item5"`
	// Seventh item ID
	Item6 int64 `json:"item6"`
	// Number of killing sprees
	KillingSprees int64 `json:"killingSprees"`
	// Number of kills
	Kills int64 `json:"kills"`
	// Largest critical strike
	LargestCriticalStrike int64 `json:"largestCriticalStrike"`
	// Largest killing spree
	LargestKillingSpree int64 `json:"largestKillingSpree"`
	// Largest multi kill
	LargestMultiKill int64 `json:"largestMultiKill"`
	// Magical damage dealt
	MagicDamageDealt int64 `json:"magicDamageDealt"`
	// Magical damage dealt to champions
	MagicDamageDealtToChampions int64 `json:"magicDamageDealtToChampions"`
	// Magic damage taken
	MagicDamageTaken int64 `json:"magicDamageTaken"`
	// Minions killed
	MinionsKilled int64 `json:"minionsKilled"`
	// Neutral minions killed
	NeutralMinionsKilled int64 `json:"neutralMinionsKilled"`
	// Neutral jungle minions killed in the enemy team's jungle
	NeutralMinionsKilledEnemyJungle int64 `json:"neutralMinionsKilledEnemyJungle"`
	// Neutral jungle minions killed in your team's jungle
	NeutralMinionsKilledTeamJungle int64 `json:"neutralMinionsKilledTeamJungle"`
	// If game was a dominion game, number of node captures
	NodeCapture int64 `json:"nodeCapture"`
	// If game was a dominion game, number of node capture assists
	NodeCaptureAssist int64 `json:"nodeCaptureAssist"`
	// If game was a dominion game, number of node neutralizations
	NodeNeutralize int64 `json:"nodeNeutralize"`
	// If game was a dominion game, number of node neutralization assists
	NodeNeutralizeAssist int64 `json:"nodeNeutralizeAssist"`
	// If game was a dominion game, player's objectives score, otherwise 0
	ObjectivePlayerScore int64 `json:"objectivePlayerScore"`
	// Number of penta kills
	PentaKills int64 `json:"pentaKills"`
	// Physical damage dealt
	PhysicalDamageDealt int64 `json:"physicalDamageDealt"`
	// Physical damage dealt to champions
	PhysicalDamageDealtToChampions int64 `json:"physicalDamageDealtToChampions"`
	// Physical damage taken
	PhysicalDamageTaken int64 `json:"physicalDamageTaken"`
	// Number of quadra kills
	QuadraKills int64 `json:"quadraKills"`
	// Sight wards purchased
	SightWardsBoughtInGame int64 `json:"sightWardsBoughtInGame"`
	// If game was a dominion game, number of completed team objectives (i.e., quests)
	TeamObjective int64 `json:"teamObjective"`
	// Total damage dealt
	TotalDamageDealt int64 `json:"totalDamageDealt"`
	// Total damage dealt to champions
	TotalDamageDealtToChampions int64 `json:"totalDamageDealtToChampions"`
	// Total damage taken
	TotalDamageTaken int64 `json:"totalDamageTaken"`
	// Total heal amount
	TotalHeal int64 `json:"totalHeal"`
	// If game was a dominion game, player's total score, otherwise 0
	TotalPlayerScore int64 `json:"totalPlayerScore"`
	// If game was a dominion game, team rank of the player's total score (e.g., 1-5)
	TotalScoreRank int64 `json:"totalScoreRank"`
	// Total dealt crowd control time
	TotalTimeCrowdControlDealt int64 `json:"totalTimeCrowdControlDealt"`
	// Total units healed
	TotalUnitsHealed int64 `json:"totalUnitsHealed"`
	// Number of tower kills
	TowerKills int64 `json:"towerKills"`
	// Number of triple kills
	TripleKills int64 `json:"tripleKills"`
	// True damage dealt
	TrueDamageDealt int64 `json:"trueDamageDealt"`
	// True damage dealt to champions
	TrueDamageDealtToChampions int64 `json:"trueDamageDealtToChampions"`
	// True damage taken
	TrueDamageTaken int64 `json:"trueDamageTaken"`
	// Number of unreal kills
	UnrealKills int64 `json:"unrealKills"`
	// Vision wards purchased
	VisionWardsBoughtInGame int64 `json:"visionWardsBoughtInGame"`
	// Number of wards killed
	WardsKilled int64 `json:"wardsKilled"`
	// Number of wards placed
	WardsPlaced int64 `json:"wardsPlaced"`
	// Flag indicating whether or not the participant won
	Winner bool `json:"winner"`
}

// MatchesBySummonerIDCall is a builder for Client.MatchesBySummonerID
type MatchesBySummonerIDCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Retrieve match list by summoner ID. (REST)
//
//
// Implementation notes: A number of optional parameters are provided for filtering. It is up to the caller to ensure that the combination of filter parameters provided is valid for the requested summoner, otherwise, no matches may be returned. If either of the beginTime or endTime parameters is set, they must both be set, although there is no maximum limit on their range. If the beginTime parameter is specified on its own, endTime is assumed to be the current time. If the endTime parameter is specified on its own, beginTime is assumed to be the start of the summoner's match history.
//
//    GET: /api/lol/{region}/v2.2/matchlist/by-summoner/{summonerId}
func (c Client) MatchesBySummonerID(ctx context.Context, region Region, summonerId int64) *MatchesBySummonerIDCall {
	path := make(map[string]string)
	path["summonerId"] = convertToString(summonerId)
	return &MatchesBySummonerIDCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *MatchesBySummonerIDCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.2/matchlist/by-summoner/{summonerId}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MatchesBySummonerIDCall) Do() (*Matches, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &Matches{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains match list information
//
// resource: "matchlist", original name: "MatchList"
type Matches struct {
	EndIndex   int32       `json:"endIndex"`
	Matches    []*MatchRef `json:"matches"`
	StartIndex int32       `json:"startIndex"`
	TotalGames int32       `json:"totalGames"`
}

//  - This object contains match reference information
//
// resource: "matchlist", original name: "MatchReference"
type MatchRef struct {
	Champion int64 `json:"champion"`
	// Legal values: MID, MIDDLE, TOP, JUNGLE, BOT, BOTTOM
	Lane       string `json:"lane"`
	MatchID    int64  `json:"matchId"`
	PlatformID string `json:"platformId"`
	// Legal values: TEAM_BUILDER_DRAFT_RANKED_5x5, RANKED_SOLO_5x5, RANKED_TEAM_3x3, RANKED_TEAM_5x5
	Queue  string `json:"queue"`
	Region string `json:"region"`
	// Legal values: DUO, NONE, SOLO, DUO_CARRY, DUO_SUPPORT
	Role string `json:"role"`
	// Legal values: PRESEASON3, SEASON3, PRESEASON2014, SEASON2014, PRESEASON2015, SEASON2015, PRESEASON2016, SEASON2016
	Season    string `json:"season"`
	Timestamp int64  `json:"timestamp"`
}

// RankedStatsCall is a builder for Client.RankedStats
type RankedStatsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get ranked stats by summoner ID. (REST)
//
//
// Implementation notes: Includes ranked stats for Twisted Treeline and Summoner's Rift.
//
//    GET: /api/lol/{region}/v1.3/stats/by-summoner/{summonerId}/ranked
func (c Client) RankedStats(ctx context.Context, region Region, summonerId int64) *RankedStatsCall {
	path := make(map[string]string)
	path["summonerId"] = convertToString(summonerId)
	return &RankedStatsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *RankedStatsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.3/stats/by-summoner/{summonerId}/ranked", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *RankedStatsCall) Do() (*RankedStats, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &RankedStats{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// StatsSummaryCall is a builder for Client.StatsSummary
type StatsSummaryCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get player stats summaries by summoner ID. (REST)
//
//
// Implementation notes: One summary is returned per queue type.
//
//    GET: /api/lol/{region}/v1.3/stats/by-summoner/{summonerId}/summary
func (c Client) StatsSummary(ctx context.Context, region Region, summonerId int64) *StatsSummaryCall {
	path := make(map[string]string)
	path["summonerId"] = convertToString(summonerId)
	return &StatsSummaryCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *StatsSummaryCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.3/stats/by-summoner/{summonerId}/summary", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *StatsSummaryCall) Do() (*PlayerStatsSummaries, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := &PlayerStatsSummaries{}
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains aggregated stat information.
//
// resource: "stats", original name: "AggregatedStatsDto"
type AggregatedStats struct {
	// Dominion only.
	AverageAssists int32 `json:"averageAssists"`
	// Dominion only.
	AverageChampionsKilled int32 `json:"averageChampionsKilled"`
	// Dominion only.
	AverageCombatPlayerScore int32 `json:"averageCombatPlayerScore"`
	// Dominion only.
	AverageNodeCapture int32 `json:"averageNodeCapture"`
	// Dominion only.
	AverageNodeCaptureAssist int32 `json:"averageNodeCaptureAssist"`
	// Dominion only.
	AverageNodeNeutralize int32 `json:"averageNodeNeutralize"`
	// Dominion only.
	AverageNodeNeutralizeAssist int32 `json:"averageNodeNeutralizeAssist"`
	// Dominion only.
	AverageNumDeaths int32 `json:"averageNumDeaths"`
	// Dominion only.
	AverageObjectivePlayerScore int32 `json:"averageObjectivePlayerScore"`
	// Dominion only.
	AverageTeamObjective int32 `json:"averageTeamObjective"`
	// Dominion only.
	AverageTotalPlayerScore int32 `json:"averageTotalPlayerScore"`
	BotGamesPlayed          int32 `json:"botGamesPlayed"`
	KillingSpree            int32 `json:"killingSpree"`
	// Dominion only.
	MaxAssists         int32 `json:"maxAssists"`
	MaxChampionsKilled int32 `json:"maxChampionsKilled"`
	// Dominion only.
	MaxCombatPlayerScore     int32 `json:"maxCombatPlayerScore"`
	MaxLargestCriticalStrike int32 `json:"maxLargestCriticalStrike"`
	MaxLargestKillingSpree   int32 `json:"maxLargestKillingSpree"`
	// Dominion only.
	MaxNodeCapture int32 `json:"maxNodeCapture"`
	// Dominion only.
	MaxNodeCaptureAssist int32 `json:"maxNodeCaptureAssist"`
	// Dominion only.
	MaxNodeNeutralize int32 `json:"maxNodeNeutralize"`
	// Dominion only.
	MaxNodeNeutralizeAssist int32 `json:"maxNodeNeutralizeAssist"`
	// Only returned for ranked statistics.
	MaxNumDeaths int32 `json:"maxNumDeaths"`
	// Dominion only.
	MaxObjectivePlayerScore int32 `json:"maxObjectivePlayerScore"`
	// Dominion only.
	MaxTeamObjective   int32 `json:"maxTeamObjective"`
	MaxTimePlayed      int32 `json:"maxTimePlayed"`
	MaxTimeSpentLiving int32 `json:"maxTimeSpentLiving"`
	// Dominion only.
	MaxTotalPlayerScore         int32 `json:"maxTotalPlayerScore"`
	MostChampionKillsPerSession int32 `json:"mostChampionKillsPerSession"`
	MostSpellsCast              int32 `json:"mostSpellsCast"`
	NormalGamesPlayed           int32 `json:"normalGamesPlayed"`
	RankedPremadeGamesPlayed    int32 `json:"rankedPremadeGamesPlayed"`
	RankedSoloGamesPlayed       int32 `json:"rankedSoloGamesPlayed"`
	TotalAssists                int32 `json:"totalAssists"`
	TotalChampionKills          int32 `json:"totalChampionKills"`
	TotalDamageDealt            int32 `json:"totalDamageDealt"`
	TotalDamageTaken            int32 `json:"totalDamageTaken"`
	// Only returned for ranked statistics.
	TotalDeathsPerSession     int32 `json:"totalDeathsPerSession"`
	TotalDoubleKills          int32 `json:"totalDoubleKills"`
	TotalFirstBlood           int32 `json:"totalFirstBlood"`
	TotalGoldEarned           int32 `json:"totalGoldEarned"`
	TotalHeal                 int32 `json:"totalHeal"`
	TotalMagicDamageDealt     int32 `json:"totalMagicDamageDealt"`
	TotalMinionKills          int32 `json:"totalMinionKills"`
	TotalNeutralMinionsKilled int32 `json:"totalNeutralMinionsKilled"`
	// Dominion only.
	TotalNodeCapture int32 `json:"totalNodeCapture"`
	// Dominion only.
	TotalNodeNeutralize      int32 `json:"totalNodeNeutralize"`
	TotalPentaKills          int32 `json:"totalPentaKills"`
	TotalPhysicalDamageDealt int32 `json:"totalPhysicalDamageDealt"`
	TotalQuadraKills         int32 `json:"totalQuadraKills"`
	TotalSessionsLost        int32 `json:"totalSessionsLost"`
	TotalSessionsPlayed      int32 `json:"totalSessionsPlayed"`
	TotalSessionsWon         int32 `json:"totalSessionsWon"`
	TotalTripleKills         int32 `json:"totalTripleKills"`
	TotalTurretsKilled       int32 `json:"totalTurretsKilled"`
	TotalUnrealKills         int32 `json:"totalUnrealKills"`
}

//  - This object contains a collection of champion stats information.
//
// resource: "stats", original name: "ChampionStatsDto"
type PlayerChampionStats struct {
	// Champion ID. Note that champion ID 0 represents the combined stats for all champions. For static information correlating to champion IDs, please refer to the LoL Static Data API.
	ID int32 `json:"id"`
	// Aggregated stats associated with the champion.
	Stats *AggregatedStats `json:"stats"`
}

//  - This object contains ranked stats information.
//
// resource: "stats", original name: "RankedStatsDto"
type RankedStats struct {
	// Collection of aggregated stats summarized by champion.
	Champions []*PlayerChampionStats `json:"champions"`
	// Date stats were last modified specified as epoch milliseconds.
	ModifyDate int64 `json:"modifyDate"`
	// Summoner ID.
	SummonerID int64 `json:"summonerId"`
}

//  - This object contains player stats summary information.
//
// resource: "stats", original name: "PlayerStatsSummaryDto"
type PlayerStatsSummary struct {
	// Aggregated stats.
	AggregatedStats *AggregatedStats `json:"aggregatedStats"`
	// Number of losses for this queue type. Returned for ranked queue types only.
	Losses int32 `json:"losses"`
	// Date stats were last modified specified as epoch milliseconds.
	ModifyDate int64 `json:"modifyDate"`
	// Player stats summary type. (Legal values: AramUnranked5x5, Ascension, Bilgewater, CAP5x5, CoopVsAI, CoopVsAI3x3, CounterPick, FirstBlood1x1, FirstBlood2x2, Hexakill, KingPoro, NightmareBot, OdinUnranked, OneForAll5x5, RankedPremade3x3, RankedPremade5x5, RankedSolo5x5, RankedTeam3x3, RankedTeam5x5, SummonersRift6x6, Unranked, Unranked3x3, URF, URFBots)
	PlayerStatSummaryType string `json:"playerStatSummaryType"`
	// Number of wins for this queue type.
	Wins int32 `json:"wins"`
}

//  - This object contains a collection of player stats summary information.
//
// resource: "stats", original name: "PlayerStatsSummaryListDto"
type PlayerStatsSummaries struct {
	// Collection of player stats summaries associated with the summoner.
	PlayerStatSummaries []*PlayerStatsSummary `json:"playerStatSummaries"`
	// Summoner ID.
	SummonerID int64 `json:"summonerId"`
}

// SummonersByNameCall is a builder for Client.SummonersByName
type SummonersByNameCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get summoner objects mapped by standardized summoner name for a given list of summoner names. (REST)
//
//
// Implementation notes: The response object contains the summoner objects mapped by the standardized summoner name, which is the summoner name in all lower case and with spaces removed. Use this version of the name when checking if the returned object contains the data for a given summoner. This API will also accept standardized summoner names as valid parameters, although they are not required.
//
//    GET: /api/lol/{region}/v1.4/summoner/by-name/{summonerNames}
func (c Client) SummonersByName(ctx context.Context, region Region, summonerNames []string) *SummonersByNameCall {
	path := make(map[string]string)
	path["summonerNames"] = convertToString(summonerNames)
	return &SummonersByNameCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *SummonersByNameCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.4/summoner/by-name/{summonerNames}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *SummonersByNameCall) Do() (map[string]*Summoner, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string]*Summoner)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

// SummonersCall is a builder for Client.Summoners
type SummonersCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get summoner objects mapped by summoner ID for a given list of summoner IDs. (REST)
//
//
//    GET: /api/lol/{region}/v1.4/summoner/{summonerIds}
func (c Client) Summoners(ctx context.Context, region Region, summonerIds []int64) *SummonersCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &SummonersCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *SummonersCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.4/summoner/{summonerIds}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *SummonersCall) Do() (map[int64]*Summoner, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string]*Summoner)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	data := make(map[int64]*Summoner)
	for k, v := range ret {
		i, err := strconv.ParseInt(k, 10, 64)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}

// MasteryPagesCall is a builder for Client.MasteryPages
type MasteryPagesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get mastery pages mapped by summoner ID for a given list of summoner IDs (REST)
//
//
//    GET: /api/lol/{region}/v1.4/summoner/{summonerIds}/masteries
func (c Client) MasteryPages(ctx context.Context, region Region, summonerIds []int64) *MasteryPagesCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &MasteryPagesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *MasteryPagesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.4/summoner/{summonerIds}/masteries", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *MasteryPagesCall) Do() (map[int64]*MasteryPages, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string]*MasteryPages)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	data := make(map[int64]*MasteryPages)
	for k, v := range ret {
		i, err := strconv.ParseInt(k, 10, 64)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}

// SummonerNamesCall is a builder for Client.SummonerNames
type SummonerNamesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get summoner names mapped by summoner ID for a given list of summoner IDs. (REST)
//
//
//    GET: /api/lol/{region}/v1.4/summoner/{summonerIds}/name
func (c Client) SummonerNames(ctx context.Context, region Region, summonerIds []int64) *SummonerNamesCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &SummonerNamesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *SummonerNamesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.4/summoner/{summonerIds}/name", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *SummonerNamesCall) Do() (map[int64]string, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string]string)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	data := make(map[int64]string)
	for k, v := range ret {
		i, err := strconv.ParseInt(k, 10, 64)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}

// RunePagesCall is a builder for Client.RunePages
type RunePagesCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get rune pages mapped by summoner ID for a given list of summoner IDs. (REST)
//
//
//    GET: /api/lol/{region}/v1.4/summoner/{summonerIds}/runes
func (c Client) RunePages(ctx context.Context, region Region, summonerIds []int64) *RunePagesCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &RunePagesCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *RunePagesCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v1.4/summoner/{summonerIds}/runes", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *RunePagesCall) Do() (map[int64]*RunePages, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string]*RunePages)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	data := make(map[int64]*RunePages)
	for k, v := range ret {
		i, err := strconv.ParseInt(k, 10, 64)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}

//  - This object contains rune page information.
//
// resource: "summoner", original name: "RunePageDto"
type RunePage struct {
	// Indicates if the page is the current page.
	Current bool `json:"current"`
	// Rune page ID.
	ID int64 `json:"id"`
	// Rune page name.
	Name string `json:"name"`
	// Collection of rune slots associated with the rune page.
	Slots []*RuneSlot `json:"slots"`
}

//  - This object contains rune pages information.
//
// resource: "summoner", original name: "RunePagesDto"
type RunePages struct {
	// Collection of rune pages associated with the summoner.
	Pages []*RunePage `json:"pages"`
	// Summoner ID.
	SummonerID int64 `json:"summonerId"`
}

//  - This object contains summoner information.
//
// resource: "summoner", original name: "SummonerDto"
type Summoner struct {
	// Summoner ID.
	ID int64 `json:"id"`
	// Summoner name.
	Name string `json:"name"`
	// ID of the summoner icon associated with the summoner.
	ProfileIconID int32 `json:"profileIconId"`
	// Date summoner was last modified specified as epoch milliseconds. The following events will update this timestamp: profile icon change, playing the tutorial or advanced tutorial, finishing a game, summoner name change
	RevisionDate int64 `json:"revisionDate"`
	// Summoner level associated with the summoner.
	SummonerLevel int64 `json:"summonerLevel"`
}

//  - This object contains mastery information.
//
// resource: "summoner", original name: "MasteryDto"
type EquippedMastery struct {
	// Mastery ID. For static information correlating to masteries, please refer to the LoL Static Data API.
	ID int32 `json:"id"`
	// Mastery rank (i.e., the number of points put into this mastery).
	Rank int32 `json:"rank"`
}

//  - This object contains mastery page information.
//
// resource: "summoner", original name: "MasteryPageDto"
type MasteryPage struct {
	// Indicates if the mastery page is the current mastery page.
	Current bool `json:"current"`
	// Mastery page ID.
	ID int64 `json:"id"`
	// Collection of masteries associated with the mastery page.
	Masteries []*EquippedMastery `json:"masteries"`
	// Mastery page name.
	Name string `json:"name"`
}

//  - This object contains masteries information.
//
// resource: "summoner", original name: "MasteryPagesDto"
type MasteryPages struct {
	// Collection of mastery pages associated with the summoner.
	Pages []*MasteryPage `json:"pages"`
	// Summoner ID.
	SummonerID int64 `json:"summonerId"`
}

//  - This object contains rune slot information.
//
// resource: "summoner", original name: "RuneSlotDto"
type RuneSlot struct {
	// Rune ID associated with the rune slot. For static information correlating to rune IDs, please refer to the LoL Static Data API.
	RuneID int32 `json:"runeId"`
	// Rune slot ID.
	RuneSlotID int32 `json:"runeSlotId"`
}

// TeamsBySummonerIDCall is a builder for Client.TeamsBySummonerID
type TeamsBySummonerIDCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get teams mapped by summoner ID for a given list of summoner IDs. (REST)
//
//
//    GET: /api/lol/{region}/v2.4/team/by-summoner/{summonerIds}
func (c Client) TeamsBySummonerID(ctx context.Context, region Region, summonerIds []int64) *TeamsBySummonerIDCall {
	path := make(map[string]string)
	path["summonerIds"] = convertToString(summonerIds)
	return &TeamsBySummonerIDCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *TeamsBySummonerIDCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.4/team/by-summoner/{summonerIds}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *TeamsBySummonerIDCall) Do() (map[int64][]*Team, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string][]*Team)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	data := make(map[int64][]*Team)
	for k, v := range ret {
		i, err := strconv.ParseInt(k, 10, 64)
		if err != nil {
			return nil, err
		}
		data[i] = v
	}
	return data, nil
}

// TeamsCall is a builder for Client.Teams
type TeamsCall struct {
	ctx        context.Context
	client     Client
	query      url.Values
	pathParams map[string]string
	region     Region
}

// Get teams mapped by team ID for a given list of team IDs. (REST)
//
//
//    GET: /api/lol/{region}/v2.4/team/{teamIds}
func (c Client) Teams(ctx context.Context, region Region, teamIds string) *TeamsCall {
	path := make(map[string]string)
	path["teamIds"] = convertToString(teamIds)
	return &TeamsCall{ctx: ctx, client: c, query: make(url.Values), pathParams: path, region: region}
}

func (c *TeamsCall) doRequest() (*http.Response, error) {
	var body io.Reader
	switch c.region {
	case BR, EUNE, EUW, JP, KR, LAN, LAS, NA, OCE, RU, TR:
	default:
		return nil, ErrNotSupportedRegion
	}
	c.query.Set("api_key", c.client.apiKey)
	c.pathParams["region"] = c.region.Name()

	path, err := uritemplates.Expand("/api/lol/{region}/v2.4/team/{teamIds}", c.pathParams)
	if err != nil {
		return nil, err
	}
	urls := c.region.baseURL() + path + "?" + c.query.Encode()

	return c.client.doRequest(c.ctx, "GET", urls, body)
}

func (c *TeamsCall) Do() (map[string]*Team, error) {
	res, err := c.doRequest()
	if res != nil {
		defer closeBody(res)
	}
	if err != nil {
		return nil, err
	}

	if err := verifyResponse(res); err != nil {
		return nil, err
	}

	ret := make(map[string]*Team)
	if err := json.NewDecoder(res.Body).Decode(&ret); err != nil {
		return nil, err
	}
	return ret, nil
}

//  - This object contains roster information.
//
// resource: "team", original name: "RosterDto"
type TeamRoaster struct {
	MemberList []*TeamMemberInfo `json:"memberList"`
	OwnerID    int64             `json:"ownerId"`
}

//  - This object contains match history summary information.
//
// resource: "team", original name: "MatchHistorySummaryDto"
type TeamMatchHistorySummary struct {
	Assists int32 `json:"assists"`
	// Date that match was completed specified as epoch milliseconds.
	Date              int64  `json:"date"`
	Deaths            int32  `json:"deaths"`
	GameID            int64  `json:"gameId"`
	GameMode          string `json:"gameMode"`
	Invalid           bool   `json:"invalid"`
	Kills             int32  `json:"kills"`
	MapID             int32  `json:"mapId"`
	OpposingTeamKills int32  `json:"opposingTeamKills"`
	OpposingTeamName  string `json:"opposingTeamName"`
	Win               bool   `json:"win"`
}

//  - This object contains team information.
//
// resource: "team", original name: "TeamDto"
type Team struct {
	// Date that team was created specified as epoch milliseconds.
	CreateDate int64  `json:"createDate"`
	FullID     string `json:"fullId"`
	// Date that last game played by team ended specified as epoch milliseconds.
	LastGameDate int64 `json:"lastGameDate"`
	// Date that last member joined specified as epoch milliseconds.
	LastJoinDate int64 `json:"lastJoinDate"`
	// Date that team last joined the ranked team queue specified as epoch milliseconds.
	LastJoinedRankedTeamQueueDate int64                      `json:"lastJoinedRankedTeamQueueDate"`
	MatchHistory                  []*TeamMatchHistorySummary `json:"matchHistory"`
	// Date that team was last modified specified as epoch milliseconds.
	ModifyDate int64        `json:"modifyDate"`
	Name       string       `json:"name"`
	Roster     *TeamRoaster `json:"roster"`
	// Date that second to last member joined specified as epoch milliseconds.
	SecondLastJoinDate int64              `json:"secondLastJoinDate"`
	Status             string             `json:"status"`
	Tag                string             `json:"tag"`
	TeamStatDetails    []*TeamStatDetails `json:"teamStatDetails"`
	// Date that third to last member joined specified as epoch milliseconds.
	ThirdLastJoinDate int64 `json:"thirdLastJoinDate"`
}

//  - This object contains team member information.
//
// resource: "team", original name: "TeamMemberInfoDto"
type TeamMemberInfo struct {
	// Date that team member was invited to team specified as epoch milliseconds.
	InviteDate int64 `json:"inviteDate"`
	// Date that team member joined team specified as epoch milliseconds.
	JoinDate int64  `json:"joinDate"`
	PlayerID int64  `json:"playerId"`
	Status   string `json:"status"`
}

//  - This object contains team statistics detail information.
//
// resource: "team", original name: "TeamStatDetailDto"
type TeamStatDetails struct {
	AverageGamesPlayed int32  `json:"averageGamesPlayed"`
	Losses             int32  `json:"losses"`
	TeamStatType       string `json:"teamStatType"`
	Wins               int32  `json:"wins"`
}
